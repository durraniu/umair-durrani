{
  "hash": "ad982d45dc5f0c277e46bcc6c37c3b8e",
  "result": {
    "markdown": "---\ntitle: \"Elevation Maps in R\"\ndescription: |\n  Learn to create 3D and Ridgeline plots with an animation bonus.\ndate: 12-25-2020\nimage: \"ontario_map.gif\"\n---\n\n\n\n\n\n\nIn this post I show you how to create aesthetically pleasant and useful maps in R using ground elevation data.\n\n## Getting the Elevation Data in R\n\nI got the elevation data from  [Geohub](https://geohub.lio.gov.on.ca/datasets/mnrf::provincial-digital-elevation-model-pdem) which provides the data for Ontario, Canada in the `.tif` format. The `.tif` file type can be easily imported in R using the `raster` package. If you want to use United States data, the [`elevatr`](https://github.com/jhollist/elevatr/) R package can help with that.  \n\nI have downloaded 2 files for Ontario, one each for north and south Ontario, and then unzipped them. Let's start by loading the libraries and importing the data.  \n\n\n::: {.cell hash='elevation-maps-in-r_cache/html/libsAndData_b193d2a1291c8ec85185804e9461da91'}\n\n```{.r .cell-code}\n# Load Libraries ----------------------------------------------------------\n\nsuppressPackageStartupMessages( library(raster) )\nsuppressPackageStartupMessages( library(tidyverse) )\nsuppressPackageStartupMessages( library(ggridges) )\nsuppressPackageStartupMessages( library(rayshader) )\nsuppressPackageStartupMessages( library(gganimate) )\nsuppressPackageStartupMessages( library(sf) )\n\n\n\n\n# Load Data ---------------------------------------------------------------\nont_s <- raster(\"PDEM_South.tif\")\n# ont_n <- raster(here::here(\"PDEM_North.tif\"))\n```\n:::\n\n\nNote that I used `here::here()` to get my file paths. Let's see what's in them:  \n\n\n\n::: {.cell hash='elevation-maps-in-r_cache/html/exploringFiles_1fe25bef421514ac6cfd1fc83c3ac1cd'}\n\n```{.r .cell-code}\nont_s\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 31655, 55685, 1762708675  (nrow, ncol, ncell)\nresolution : 30, 30  (x, y)\nextent     : 151020, 1821570, 11620380, 12570030  (xmin, xmax, ymin, ymax)\ncrs        : +proj=lcc +lat_0=0 +lon_0=-85 +lat_1=44.5 +lat_2=53.5 +x_0=930000 +y_0=6430000 +datum=NAD83 +units=m +no_defs \nsource     : PDEM_South.tif \nnames      : PDEM_South \n```\n:::\n\n```{.r .cell-code}\n# ont_n\n```\n:::\n\n\nThey are clearly raster file types. You can see in the `dimensions` section that the number of cells (i.e. number of data points) is quite a large number for both layers. This means that if we try to plot these data with a typical RAM size, say 8GB, we'd have a bad time^[Read the discussion here: https://stackoverflow.com/questions/61535383/r-runs-out-of-memory-plotting-data-frame-with-ggplot2].  So, to create maps we'd need to decrease the size of these raster layers.  \n\nBefore going to the next step, an important thing to note here is that the `crs` section above indicates that the units of the x, y and elevation coordinates are meters. The elevation is stored here under the names `PDEM_South` and `PDEM_North` in the two raster layers.  \n\n\n## Slimming Down the Raster Data\n\nThe `sampleRegular` function from the `raster` package lets you take a sample of the original raster data by specifying the `size` argument. I experimented with different sizes, and was satisfied with `size=50000`, as it provided a good visual quality in the maps. The last argument here is `asRaster` that returns a raster data when `TRUE`.   \n\nOnce we get a reduced raster data, we use the `rayshader::raster_to_matrix()` function to put all the elevation values in a 2D matrix where the 2 dimensions are x and y coordinates. Following shows the results (only the first 5 rows and columns for each layer):  \n\n\n\n::: {.cell hash='elevation-maps-in-r_cache/html/unnamed-chunk-1_00cd4139f1e3296acb4be42fd9203f18'}\n\n```{.r .cell-code}\nont_s_m <- ont_s %>% \n  raster::sampleRegular(ont_s, size=50000, asRaster=TRUE) %>%\n  rayshader::raster_to_matrix()\n\nont_s_m[1:5, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]     [,2]     [,3]     [,4]     [,5]\n[1,]       NA 345.7590 343.8626 339.1616       NA\n[2,] 341.2442 344.7713 351.7452 340.4780 326.4015\n[3,] 346.9645 350.9861 349.9320 330.7751 336.5002\n[4,] 355.3123 357.0607 337.0629 333.1272 338.1620\n[5,] 358.0299 358.2284 334.0108 329.6138 329.7867\n```\n:::\n\n```{.r .cell-code}\n# ont_n_m <- ont_n %>% \n#   raster::sampleRegular(ont_n, size=50000, asRaster=TRUE) %>%\n#   rayshader::raster_to_matrix()\n# \n# ont_n_m[1:5, 1:5]\n```\n:::\n\n\n\n## 3D Raster Maps with Rayshader\n\nWe use the awesome [`rayshader package`](https://github.com/tylermorganwall/rayshader) here to plot the raster map in 3D.\n\n\n\n\n::: {.cell hash='elevation-maps-in-r_cache/html/rasterMapsOne_db53831ec52f080be9bc8ed3a5cbc5c5'}\n\n```{.r .cell-code}\nont_s_m %>%\n  sphere_shade(texture = \"desert\") %>%\n  add_shadow(ray_shade(ont_s_m, zscale = 30), 0.5) %>%\n  add_shadow(ambient_shade(ont_s_m), 0) %>%\n  plot_3d(ont_s_m, zscale = 10, fov = 0,\n          theta = 0, zoom = 0.75, phi = 70,\n          windowsize = c(1000, 800),\n          solid=FALSE)\n\nSys.sleep(0.6)\nrender_snapshot(clear=T, title_text = \"Ontario (South)\",\n                filename=\"ont_s.png\")\n\nrgl::rgl.close()\n\n## For some reason, rayshader is not rendering the snapshot\n## of this map.\n```\n:::\n\n\n![](ont_s.png)    \n\n\n\n## Creating Ridgeline Maps\n\nRaster maps are beautiful but take long time to render. Another technique that can show the elevation data very effectively is a `ridgeline plot`. I was previously familiar with the [`ggridges package`](https://github.com/wilkelab/ggridges) but was recently reminded of it when I saw the ridgeline plots [app](https://anvaka.github.io/peak-map/#7.68/47.727/-122.574) made by [Andrei Kashcha](https://github.com/anvaka/peak-map). So, I decided to use elevation height in the `ggridges::geom_ridgeline()` function.  \n\nBut a ridgeline plot uses 3 arguments, x, y, and height. So, to proceed, we need to extract these coordinates from the raster files. Again, we use the `raster::sampleRegular` function for slimming the data, but also use the `xy=TRUE` option to get the three coordinates:  \n\n\n\n::: {.cell hash='elevation-maps-in-r_cache/html/coordinateData_b395491ccacfe95bef0c17ca23043025'}\n\n```{.r .cell-code}\n## Sample 10000 values\ndf_s <- data.frame(sampleRegular(ont_s, 10000, xy=TRUE))\n# df_n <- data.frame(sampleRegular(ont_n, 10000, xy=TRUE))\n\n\n## Rename to 'elevation'\ndf_s <- df_s %>% \n  rename(elevation = PDEM_South)\n\n# df_n <- df_n %>% \n#   rename(elevation = PDEM_North)\n\n\n## Combine the two\ndf <- df_s#bind_rows(df_s, df_n)\n\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       x        y elevation\n1 157335 12563715  341.1952\n2 169995 12563715  354.5818\n3 182655 12563715  364.6080\n4 195285 12563715  336.9090\n5 207945 12563715  328.2127\n6 220605 12563715  320.1098\n```\n:::\n:::\n\n\nNote that `elevation` above is not completely `NA` (you are seeing the first 6 rows only).   \n\n\n\n> My attempts to use `ggridges::geom_ridgeline()` were not successful. Instead, the other function, `ggridges::geom_density_ridges` is what can effectively generate the nice elevation lines for creating the 3D effect that Andrei showed. I learnt this from [Travis M. White's blogpost](https://cartographicperspectives.org/index.php/journal/article/view/1536/1726). I also found great tips for theming the map.\n\n\n### Plots\n\nThe data is ready now, back to making the maps. A first try: \n\n\n\n::: {.cell hash='elevation-maps-in-r_cache/html/unnamed-chunk-2_5e9af5c835a19f0471062ca621f0730d'}\n\n```{.r .cell-code}\nggplot() +\n  geom_density_ridges(data = df,\n                      aes(x, y, \n                          group=y,\n                          height = elevation),\n                      stat = \"identity\",\n                      scale=20) +\n  theme_void() \n```\n\n::: {.cell-output-display}\n![](elevation-maps-in-r_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\nSee the 3D effect?  \n\nThe `scale` argument controls the overlap between the ridgelines. I experimented with different values and settled with 20.  \n\nNow with a dark theme:  \n\n\n::: {.cell hash='elevation-maps-in-r_cache/html/unnamed-chunk-3_777dd1d1e1d40b6a06513df7eef249f8'}\n\n```{.r .cell-code}\nggplot() +\n  geom_density_ridges(data = df,\n                      aes(x, y, \n                          group=y,\n                          height = elevation),\n                      stat = \"identity\",\n                      scale=20,\n                      fill=\"black\",\n                      color=\"white\") +\n  scale_x_continuous(name = \"Ontario\") +\n  theme_void() +\n  theme(\n             panel.background = element_rect(fill = \"black\"),\n            \n             plot.background = element_rect(fill = \"black\"),\n           \n             axis.title.x = element_text(colour = 'white', \n                                         size = 18))\n```\n\n::: {.cell-output-display}\n![](elevation-maps-in-r_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nFor some reason, this reminded me of neon signs. So, I got an idea!\n\n\n## Animating the Ridgeline Map\n\nLet's animate the map with colors. For doing so, I create 2 more copies of the data `df` and then give one color to each (there may be a better way to do this). Then I use `transition_reveal` to color the lines turn by turn:  \n\n\n::: {.cell hash='elevation-maps-in-r_cache/html/animate1_e37b64a058d15cf5cafdd48037c3b497'}\n\n```{.r .cell-code}\ncolos = rep(c(\"red\", \"yellow\", \"green\"), each = nrow(df))\n\nretro <- bind_rows(df, df, df) %>% \n  mutate(colorz = colos)\n\nani1 <- ggplot(data = retro ,\n       aes(x, y, \n           group=y,\n           height = elevation))+\n  geom_density_ridges(stat = \"identity\",\n                      scale=20,\n                      fill=\"black\",\n                      aes(color=colorz)) +\n  scale_x_continuous(name = \"Ontario\") +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    panel.background = element_rect(fill = \"black\"),\n    \n    plot.background = element_rect(fill = \"black\"),\n    \n    axis.title.x = element_text(colour = 'white', \n                                size = 18)) +\n    transition_states(colorz,\n                    transition_length = 2,\n                    state_length = 1)\n\nani1\n```\n\n::: {.cell-output-display}\n![](elevation-maps-in-r_files/figure-html/animate1-1.gif)\n:::\n:::\n\n\n\nOf course, we can also animate by x or y dimensions:  \n\n\n::: {.cell hash='elevation-maps-in-r_cache/html/animate2_2cc14d12a60b424080a9b1ec8b4950e1'}\n\n```{.r .cell-code}\nani2 <- ggplot(data = df,\n       aes(x, y, \n           group=y,\n           height = elevation))+\n  geom_density_ridges(stat = \"identity\",\n                      scale=8,\n                      fill=\"black\",\n                      color = \"white\") +\n  scale_x_continuous(name = \"Ontario\") +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    panel.background = element_rect(fill = \"black\"),\n    \n    plot.background = element_rect(fill = \"black\"),\n    \n    axis.title.x = element_text(colour = 'white', \n                                size = 18)) + \n  transition_manual(x, cumulative = T) + \n  ease_aes('linear')\n\n\nani2\n```\n\n::: {.cell-output-display}\n![](elevation-maps-in-r_files/figure-html/animate2-1.gif)\n:::\n:::\n\n\nThis ends the blogpost. I hope you'd find something useful here for your mapping needs.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}