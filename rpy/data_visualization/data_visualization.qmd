---
title: "Getting started with exploratory data visualization"
description: "Learn to use ggplot2 and plotnine to explore data"
author: "Umair Durrani"
image: "imagee.png"
warning: false
cache: true
categories:
  - visualization
  - ggplot2
  - plotnine
  - plotting
  - graphs
---

```{r, include=FALSE}
reticulate::use_condaenv("C:/Users/umair/anaconda3/envs/homl3/python.exe")
```


We begin by loading the required visualization packages:

::: panel-tabset
### R
```{r}
library(ggplot2)
library(arrow)
```

### Python
```{python}
import pandas as pd
from plotnine import *
```
:::


Next we load data and take a quick look:

::: panel-tabset
### R
```{r}
df <- arrow::read_parquet("data/df.parquet")
knitr::kable(head(df))
```

The `kable()` function makes the table output pretty in html.

### Python
```{python}
df = pd.read_parquet("data/df.parquet")
df.head()
```
:::

The dataset was stored as a `parquet` file in a folder named `data`. `parquet` format is faster to read and write compared to the `csv` format. If you'd like to know more about the source of the data and how to store it yourself, read [this post](to-be-added). 

## Visualizing distributions

### Boxplot

Let's plot vehicle length first.  

Start with an empty canvas:

::: panel-tabset
### R
```{r}
ggplot(data = df)
```

### Python
```{python}
ggplot(data = df)
```
:::

Then add aesthetic mappings (we map vehicle class to x-axis and vehicle length to y-axis):  

::: panel-tabset
### R
```{r}
ggplot(data = df,
       mapping = aes(x = v_class, y = v_length))
```

### Python
```{python}
ggplot(data = df,
       mapping = aes(x = "v_class", y = "v_length"))
```

Note that the dataset `df` is specified without quotes but the columns `v_class` and `v_length` are provided in quotes. 
:::

You see the range of vehicle class and length variables on the plot, but there is no data on the plot pane because we did not specify how to draw it.  

Let's use the `geom`etrical object `boxplot` to visualize the distribution of length of various vehicles:  

::: panel-tabset
### R
```{r}
ggplot(data = df,
       mapping = aes(x = v_class, y = v_length)) +
  geom_boxplot()
```

### Python
```{python}
(
  ggplot(data = df,
       mapping = aes(x = "v_class", y = "v_length")) +
  geom_boxplot()
  )
```

Note that the code is wrapped in parentheses `()`. This is because the plot would not render without wrapping the code it in `()`. 
:::
::: {.column-margin}
![](box-plot-explained.gif)  

Reading a Boxplot: https://flowingdata.com/2008/02/15/how-to-read-and-use-a-box-and-whisker-plot/
:::

Here we see three vehicle classes with the distribution of their length. Based on the information that `1`, `2`, and `3` represent `motorcycle`, `car` and `heavy-vehicle`, we change the labels on the plot:  

::: panel-tabset
### R
```{r}
ggplot(data = df,
       mapping = aes(x = v_class, y = v_length)) +
  geom_boxplot() +
  scale_x_discrete(labels = c("Motorcycle", "Car", "HV"))
```

The function `c()` means combine. Here we combine three string (text) items.

### Python
```{python}
(
  ggplot(data = df,
       mapping = aes(x = "v_class", y = "v_length")) +
  geom_boxplot() +
  scale_x_discrete(labels = ["Motorcycle", "Car", "HV"])
  )
```

`[]` combines multiple strings in a data structure called a `list`.
:::

We used `scale_x_discrete()` because `v_class` is a discrete data type with 3 categories. We used the parameter `labels` to specify the custom labels that replaced the actual data (`1`, `2`, and `3`) on the plot.    

The main finding in this plot is that heavy-vehicles are much longer than cars and motorcycles. To make this plot even more readable, we provide the `labs` (labels) of the plot:  

::: panel-tabset
### R
```{r}
ggplot(data = df,
       mapping = aes(x = v_class, y = v_length)) +
  geom_boxplot() +
  scale_x_discrete(labels = c("Motorcycle", "Car", "HV")) +
  labs(x = NULL,
       y = "Length (m)")
```

Specifying `NULL` for the `x`-axis label completely removes it.

### Python
```{python}
(
  ggplot(data = df,
       mapping = aes(x = "v_class", y = "v_length")) +
  geom_boxplot() +
  scale_x_discrete(labels = ["Motorcycle", "Car", "HV"]) +
  labs(x = "",
       y = "Length (m)")
  )
```

Specifying an empty string (`""`) for the `x`-axis label removes it.
:::


### Histogram and Density plots

Histogram and Density plots also help in understanding a variable distribution. 

::: {.column-margin}
**How histograms work:** https://flowingdata.com/2017/06/07/how-histograms-work/
:::

Let's look at the histogram of speed (`v_vel`):  

::: panel-tabset
### R
```{r}
# Speed distribution
ggplot(data = df) +
  geom_histogram(aes(x = v_vel, color = v_class, fill = v_class), 
                 alpha = 0.4) +
  scale_color_discrete(labels = c("motorcycle", "car", "HV")) +
  scale_fill_discrete(labels = c("motorcycle", "car", "HV")) +
  labs(x = "Speed (m/s)",
       color = "Vehicle Class",
       fill = "Vehicle Class")
```

### Python
```{python}
# Speed distribution
(
  ggplot(data = df) +
  geom_histogram(aes(x = "v_vel", color = "v_class", fill = "v_class"), 
                 alpha = 0.4) +
  scale_color_discrete(labels = ["motorcycle", "car", "HV"]) +
  scale_fill_discrete(labels = ["motorcycle", "car", "HV"]) +
  labs(x = "Speed (m/s)",
       color = "Vehicle Class",
       fill = "Vehicle Class")
       )
```
:::

In this piece of code, we have used many new features:  

* `color` aesthetic: To map the `v_class` variable to the border color (also called as stroke) of the bars in histogram  
* `fill` aesthetic: To map the `v_class` variable to the fill color of the bars in histogram  
* `alpha` property: The transparency level of the visualization. `0.4` means 40%. The default is 100%. Note that `alpha` is provided outside the `aes`thetics function   
* Two scales are provided, one each for `color` and `fill` aesthetics  
* Within `labs()` the labels for `color` and `fill` aesthetics are also provided in addition to the `x` aesthetic  

You may have noticed that `y` aesthetic is not specified here. This is because observation count was first calculated by ggplot2 in each interval of speed. Then the count was mapped to `y`.


The height of each bar in a histogram corresponds to the count of observations (rows in a dataframe) of the variable (speed in this case). We can see that the speed typically varies between 5 - 20 m/s. However, since the histograms are plotted on top of each other AND the count of observations varies significantly between different vehicle classes, we need a better visualization.    

Instead of count on y-axis, we can ask ggplot to estimate the [density](https://clauswilke.com/dataviz/histograms-density-plots.html) and map it as the `y` aesthetic:  


::: panel-tabset
### R
```{r}
ggplot(data = df) +
  geom_density(aes(x = v_vel, color = v_class, fill = v_class), 
                 alpha = 0.4) +
  scale_color_discrete(labels = c("motorcycle", "car", "HV")) +
  scale_fill_discrete(labels = c("motorcycle", "car", "HV")) +
  labs(x = "Speed (m/s)",
       color = "Vehicle Class",
       fill = "Vehicle Class")
```

### Python
```{python}
(
  ggplot(data = df) +
  geom_density(aes(x = "v_vel", color = "v_class", fill = "v_class"), 
                 alpha = 0.4) +
  scale_color_discrete(labels = ["motorcycle", "car", "HV"]) +
  scale_fill_discrete(labels = ["motorcycle", "car", "HV"]) +
  labs(x = "Speed (m/s)",
       color = "Vehicle Class",
       fill = "Vehicle Class")
       )
```
:::

Now we can clearly see the differences in the speed distribution of different types of vehicles. Most motorcycles were much faster than cars and HVs.  


## Visualizing relationships

Space headway (or spacing) is generally assumed to vary with vehicle speed on highways. We can look at this relationship by mapping both the variables to `x` and `y` aesthetics. 

Since there are `r nrow(df)` observations in these data, using a hexagonal heatmap seems to be a good choice. ggplot2 documentation defines `geom_hex` as:  

> Divides the plane into regular hexagons, counts the number of cases in each hexagon, and then (by default) maps the number of cases to the hexagon fill. 

Let's use it:

::: panel-tabset
### R
```{r}
ggplot(data = df,
       aes(x = v_vel, y = space_headway)) +
  geom_hex() +
  geom_smooth(se = FALSE, color = "orange") +
  labs(x = "Speed (m/s)",
       y = "Spacing (m)")
```

### Python

`geom_hex` is not yet implemented in `plotnine`. So, we create a scatterplot using `geom_point()`:

```{python}
(
  ggplot(data = df, 
        mapping = aes(x = "v_vel", y = "space_headway")) +
  geom_point(alpha = 0.1) +
  geom_smooth(se = False, color = "orange") +
  labs(x = "Speed (m/s)",
       y = "Spacing (m)")
       )
```
:::

The plot shows a linear relationship between speed and spacing: vehicles at higher speed generally keep a higher spacing from the lead vehicle (preceding vehicle). This relationship is explicitly modeled by ggplot2 behind the scenes as it fits an algorithm to the data. The command used to achieve that is `geom_smooth`.   


Car-following models employ spacing and speed-difference from the lead vehicle to forecast the speed of the subject vehicle. Let's plot the spacing vs speed-difference plot to see the typical speed-difference at different levels of spacing:

::: panel-tabset
### R
```{r}
ggplot(data = df,
       aes(x = v_vel - preceding_vel, y = space_headway)) +
  geom_point(aes(color = (v_vel - preceding_vel) < 0), 
             alpha = 0.5, shape = "x") +
  facet_wrap(~v_class) +
  labs(x = "Speed (m/s)",
       y = "Spacing (m)")
```

### Python
```{python}
(
  ggplot(data = df,
       mapping = aes(x = "v_vel - preceding_vel", y = "space_headway")) +
  geom_point(aes(color = "(v_vel - preceding_vel) < 0"), 
  alpha = 0.5, shape = "x") +
  facet_wrap("~v_class") +
  labs(x = "Speed (m/s)",
       y = "Spacing (m)")
       )
```
:::

In this scatterplot, we used four new things:  

* mapped a calculation from two columns to the `x` aesthetic  
* mapped the calculation`(v_vel - preceding_vel) < 0` to colour
* specified a different shape of the data points. You can find more shapes [here](https://r4ds.hadley.nz/layers.html#fig-shapes)  
* created subplots for each `v_class` by specifying it in `facet_wrap()`. Another option is `facet_grid()`  

The scatterplot shows that most of the data lies between -2.5 and 2.5 m/s.