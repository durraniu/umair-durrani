[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Welcome to my website"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Manipulating text with {quanteda} and creating a table with {reactable}\n\n\n\n\n\n\nFeb 7, 2021\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJan 1, 2021\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nLearn to create 3D and Ridgeline plots with an animation bonus.\n\n\n\n\n\n\nDec 25, 2020\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDec 16, 2020\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSep 14, 2020\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSep 13, 2020\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSep 7, 2020\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Umair Durrani",
    "section": "",
    "text": "I am a research associate in transportation engineering at the Civil and Environmental Engineering Department at the University of Windsor. I study and develop models of road users for traffic flow modeling. Moreover, I teach programmatic data analysis to students in the Transportation Systems Innovation Lab.\nI am also an instructor of Data Analytics at St. Clair College, Windsor, Ontario. I teach Statistics and analytical tools (Python, R, Tableau, Excel), and manage capstone projects of students from diverse backgrounds.\nI speak English, Urdu and R (programming) fluently. You can get in touch with me via email or twitter.\n\n\n\n\n\nMachine Learning Applications in Transportation\nIntelligent Transportation Systems\nDriver Behaviour\nConnected and Autonomous Vehicles\nSpatiotemporal Analysis of Transportation Networks\n\n\n\n\n\n\nPhD in Civil Engineering, 2022 \n\nUniversity of Windsor, Ontario, Canada\n\nB.Sc. in Transportation Engineering, 2009 \n\nUniversity of Engineering and Technology, Lahore, Pakistan"
  },
  {
    "objectID": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html",
    "href": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html",
    "title": "Draw cars with ggplot2",
    "section": "",
    "text": "Thanks to BrodieG for answering my stackoverflow question about drawing diagrams in R."
  },
  {
    "objectID": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#creating-geom_car",
    "href": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#creating-geom_car",
    "title": "Draw cars with ggplot2",
    "section": "Creating geom_car",
    "text": "Creating geom_car\nCreating a new geom in ggplot2 is much more complicated then using the ggplot2 interface. The official gpplot2 book, ggplot2: Elegant Graphics for Data Analysis, says the following:\n\nWhen making the jump from user to developer, it is common to encounter frustrations because the nature of the ggplot2 interface is very different to the structure of the underlying machinery that makes it work\n\nAnd I completely agree. The chapter that the above quote is from explains that ggplot2 uses the ggproto class system to create new objects such as geoms.\nThe following shows the use of ggproto that creates the geom_car. Again, the code is not mine but provided by Brodie G (thanks!).\nFirst, load libraries.\n\nLoad Libraries\n\nsuppressPackageStartupMessages( library(tidyverse) )\n\nWarning: package 'tidyverse' was built under R version 4.0.5\n\n\nWarning: package 'tidyr' was built under R version 4.0.5\n\nsuppressPackageStartupMessages( library(here) )\nsuppressPackageStartupMessages( library(readr) )\n\n\n\nLoad data\nI am using a dataset of 2 cars. The Following car is approaching a Lead car from a large distance. The Lead car is stopped. The dataset contains the x and y coordinates of the centroid of cars and their sizes.\n\ndf <- read_csv(\"driver_data.csv\")\n\n\n-- Column specification --------------------------------------------------------\ncols(\n  Time_s = col_double(),\n  ED_x_m = col_double(),\n  ED_y_m = col_double(),\n  LV_x_m = col_double(),\n  LV_y_m = col_double(),\n  LV_length_m = col_double(),\n  LV_width_m = col_double(),\n  visual_angle_W = col_double(),\n  visual_angle_H = col_double(),\n  tau = col_double(),\n  ED_length_m = col_double(),\n  ED_width_m = col_double()\n)\n\nhead(df)\n\n# A tibble: 6 x 12\n  Time_s ED_x_m ED_y_m LV_x_m LV_y_m LV_length_m LV_widt~1 visua~2 visua~3   tau\n   <dbl>  <dbl>  <dbl>  <dbl>  <dbl>       <dbl>     <dbl>   <dbl>   <dbl> <dbl>\n1      1  4341. -8921.  3991. -7732.        5.39      2.29 0.00185 0.00128  55.1\n2      2  4335. -8899.  3991. -7732.        5.39      2.29 0.00189 0.00130  52.8\n3      3  4329. -8877.  3991. -7732.        5.39      2.29 0.00193 0.00133  50.7\n4      4  4322. -8854.  3991. -7732.        5.39      2.29 0.00197 0.00136  48.6\n5      5  4315. -8831.  3991. -7732.        5.39      2.29 0.00201 0.00138  46.9\n6      6  4308. -8808.  3991. -7732.        5.39      2.29 0.00205 0.00141  45.3\n# ... with 2 more variables: ED_length_m <dbl>, ED_width_m <dbl>, and\n#   abbreviated variable names 1: LV_width_m, 2: visual_angle_W,\n#   3: visual_angle_H\n# i Use `colnames()` to see all variable names\n\n\n\n\nCoordinates plot\nFollowing plot shows that in the original data format, the Following car moves up and left towards the lead car.\n\nggplot(data = df,\n       aes(x = ED_x_m, y = ED_y_m)) +\n  geom_line(aes(color = \"Following car\"))\n\n\n\n\n\n\nStep 1: Create a car image with no fill color\nThe stackoverflow answer comes with a car image, but I wanted to experiment with my own image. So, I created one with no fill color. This was important to enable the fill method in geom_car. Then it was read by the png::readPNG method:\n\ncar.raster <- png::readPNG(\"car4.png\")\n\nstr(car.raster)\n\n num [1:238, 1:505, 1:4] 0 0.184 0.184 0.184 0.184 ...\n\n\n\n\nStep 2: Create a graphical object (grob) from the image\n\n# Generate a car 'grob' using a baseline PNG\n\n# The `grid` grob actually responsible for rendering our car, \n# combines our transparent car elements with a background rectangle\n# for color/fill.\n\ncarGrob <- function(x, y, length, width, gp) {\n  grid::grobTree(\n    grid::rectGrob(\n      x, y, hjust=.5, height=width, width=length,\n      gp = gp\n    ),\n    grid::rasterGrob(\n      car.raster, x=x, y=y, hjust=.5, height=width, width=length\n    ) ) }\n\n\n\nStep 3: Map the data to the grob using ggproto\n\n# The `ggproto` object that maps our data to the `grid` grobs\n\nGeomCar <- ggplot2::ggproto(\"GeomCar\", ggplot2::Geom,\n                            # Generate grobs from the data, we have to reconvert length/width so\n                            # that the transformations persist\n                            \n                            draw_panel=function(self, data, panel_params, coords) {\n                              with(\n                                coords$transform(data, panel_params),\n                                carGrob(\n                                  x, y, length=xmax-xmin, width=ymax-ymin,\n                                  gp=grid::gpar(\n                                    col = colour, fill = alpha(fill, alpha),\n                                    lwd = size * .pt, lty = linetype, lineend = \"butt\"\n                                  ) ) ) },\n                            # Convert data to coordinates that will get transformed (length/width don't\n                            # normally).\n                            \n                            setup_data=function(self, data, params) {\n                              transform(data,\n                                        xmin = x - length / 2, xmax = x + length / 2,\n                                        ymin = y - width / 2, ymax = y + width / 2\n                              ) },\n                            # Required and default aesthetics\n                            \n                            required_aes=c(\"x\", \"y\", \"length\", \"width\"),\n                            default_aes = aes(\n                              colour = NA, fill = \"grey35\", size = 0.5, linetype = 1, alpha = NA\n                            ),\n                            # Use the car grob in the legend\n                            \n                            draw_key = function(data, params, size) {\n                              with(\n                                data,\n                                carGrob(\n                                  0.5, 0.5, length=.75, width=.5,\n                                  gp = grid::gpar(\n                                    col = colour, fill = alpha(fill, alpha),\n                                    lwd = size * .pt, lty = linetype, lineend = \"butt\"\n                                  ) ) ) }\n)\n\n\n\nStep 4: Create the external interface i.e. the geom_car layer\n\n# External interface\n\ngeom_car <- function(\n  mapping=NULL, data=NULL, ..., inherit.aes=TRUE, show.legend=NA\n) {\n  layer(\n    data=data, mapping=mapping, geom=GeomCar, position=\"identity\",\n    stat=\"identity\", show.legend = show.legend, inherit.aes = inherit.aes,\n    params=list(...)\n  )\n}"
  },
  {
    "objectID": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#plotting-the-cars",
    "href": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#plotting-the-cars",
    "title": "Draw cars with ggplot2",
    "section": "Plotting the cars",
    "text": "Plotting the cars\nI can now use geom_car to plot the cars. Since the coordinates change every second (see the Time_s column above), I need to filter for one time only. So, I choose Time_s == 49.\n\nAttempt 1 to plot cars\n\nggplot(df %>% filter(Time_s == 49) ) +\n  geom_car(aes(x=ED_x_m, y=ED_y_m, \n               length=ED_length_m, width=ED_width_m, \n               fill=\"ed\")) +\n  geom_text(aes(x=ED_x_m, y=ED_y_m+5), \n            label = \"Following Car\") +\n  \n  geom_car(aes(x=LV_x_m, y=LV_y_m, \n               length=LV_length_m, width=LV_width_m, \n               fill=\"lv\")) +\n  geom_text(aes(x=LV_x_m, y=LV_y_m+5), \n            label = \"Lead Car\\n(stationary)\") +\n\n  coord_equal(ratio = 0.7) +\n  theme(legend.position = \"none\")\n\n\n\n\nThis does not look right. The Following car seems to be ahead of the lead car. Also, due to the elongated scale, the Following car appears to be in a different lane. The main reason is the unusual coordinates. The x coordinates decrease as the Following car gets closer to the lead car.\nI can fix this by scaling: subtracting the x coordinates from the largest x coordinate in the data.\n\n\nAttemp 2: Adjust the coordinates and plot again\n\nAdjust coordinates:\n\nfirst_ed_x_coord <- df %>% pull(ED_x_m) %>% range() %>% tail(1)\n\ndf <- df %>% \n  mutate(\n    ED_x_m_a = abs(ED_x_m - first_ed_x_coord),\n    LV_x_m_a = abs(LV_x_m - first_ed_x_coord)\n         )\n\n\n\nPlot:\n\nggplot(df %>% filter(Time_s == 49) ) +\n  geom_car(aes(x=ED_x_m_a, y=ED_y_m, \n               length=ED_length_m, width=ED_width_m, \n               fill=\"ed\")) +\n  geom_text(aes(x=ED_x_m_a, y=ED_y_m+5), \n            label = \"Following Car\") +\n  \n  geom_car(aes(x=LV_x_m_a, y=LV_y_m, \n               length=LV_length_m, width=LV_width_m, \n               fill=\"lv\")) +\n  geom_text(aes(x=LV_x_m_a, y=LV_y_m+5), \n            label = \"Lead Car\\n(stationary)\") +\n\n  coord_equal(ratio = 0.7) +\n  theme(legend.position = \"none\")\n\n\n\n\nThis is better. Now, to fix the problem of the elongated y coordinate, I can fix them to a single value, because I’m mainly interested in the movement along the x-axis. But note that this might not be a good idea if there is a large change in y coordinate (e.g. in a lane change).\n\n\n\nAttempt 3 - Fixing y coordinate\n\ncar_plot <- ggplot(df %>% filter(Time_s == 49) ) +\n  geom_car(aes(x=ED_x_m_a, y=300, \n               length=ED_length_m, width=ED_width_m, \n               fill=\"ed\")) +\n  geom_text(aes(x=ED_x_m_a, y=300+5), \n            label = \"Following Car\") +\n  \n  geom_car(aes(x=LV_x_m_a, y=300, \n               length=LV_length_m, width=LV_width_m, \n               fill=\"lv\")) +\n  geom_text(aes(x=LV_x_m_a, y=300+5), \n            label = \"Lead Car\\n(stationary)\") +\n  theme_void() +\n  coord_equal(ratio = 1) +\n  theme(legend.position = \"none\",\n        axis.text = element_blank(),\n        axis.title = element_blank(),\n        axis.ticks = element_blank())\n\ncar_plot\n\n\n\n\nThis looks much better. :D"
  },
  {
    "objectID": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#car-rear-view",
    "href": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#car-rear-view",
    "title": "Draw cars with ggplot2",
    "section": "Car Rear View",
    "text": "Car Rear View\nI also created a geom_car_rear by using a different image (car rear created in powerpoint). Following plots the car rear at time = 49 s.\n\nggplot(df %>% filter(Time_s == 49)) +\n  geom_car_rear(aes(x=0, y=0, length=visual_angle_W,\n               width=visual_angle_H), fill=\"black\") +\n  theme_void()"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "",
    "text": "Thanks to Robert Walker for showing how to combine multiple animations using the magick package in R.\n\n\nWow, you can side-by-side gganimates with imagemagick. That was fun to put together. #rstats #tidyTuesday An adaptation of measles and a map… pic.twitter.com/FPOgAOQS84\n\n— Robert Walker (@PieRatio) December 16, 2019"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#load-data",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#load-data",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Load data",
    "text": "Load data\nI am using a dataset that contains car positions, speed and distance (also called as spacing).\n\nsuppressPackageStartupMessages( library(tidyverse) )\nsuppressPackageStartupMessages( library(magick) )\nsuppressPackageStartupMessages( library(gganimate) )\nsuppressPackageStartupMessages( library(here) )\nsuppressPackageStartupMessages( library(readr) )\n\ndf <- read_csv(\"vb.csv\")\n\n\n-- Column specification --------------------------------------------------------\ncols(\n  Time_s = col_double(),\n  ED_x_m = col_double(),\n  LV_x_m = col_double(),\n  LV_length_m = col_double(),\n  LV_width_m = col_double(),\n  visual_angle_W = col_double(),\n  visual_angle_H = col_double(),\n  tau = col_double(),\n  ED_speed_mps = col_double(),\n  LV_speed_mps = col_double(),\n  LV_frspacing_m = col_double(),\n  ED_gas_pedal_pos = col_double(),\n  ED_brake_pedal_force_kg = col_double(),\n  tau_inv = col_double()\n)\n\ndf\n\n# A tibble: 49 x 14\n   Time_s ED_x_m LV_x_m LV_lengt~1 LV_wi~2 visua~3 visua~4   tau ED_sp~5 LV_sp~6\n    <dbl>  <dbl>  <dbl>      <dbl>   <dbl>   <dbl>   <dbl> <dbl>   <dbl>   <dbl>\n 1      1  4341.  3991.       5.39    2.29 0.00185 0.00128  55.1    22.4       0\n 2      2  4335.  3991.       5.39    2.29 0.00189 0.00130  52.8    22.9       0\n 3      3  4329.  3991.       5.39    2.29 0.00193 0.00133  50.7    23.5       0\n 4      4  4322.  3991.       5.39    2.29 0.00197 0.00136  48.6    24.0       0\n 5      5  4315.  3991.       5.39    2.29 0.00201 0.00138  46.9    24.3       0\n 6      6  4308.  3991.       5.39    2.29 0.00205 0.00141  45.3    24.7       0\n 7      7  4302.  3991.       5.39    2.29 0.00210 0.00145  43.7    25         0\n 8      8  4294.  3991.       5.39    2.29 0.00215 0.00148  42.1    25.3       0\n 9      9  4287.  3991.       5.39    2.29 0.00220 0.00152  40.6    25.7       0\n10     10  4280.  3991.       5.39    2.29 0.00226 0.00156  39.1    26.0       0\n# ... with 39 more rows, 4 more variables: LV_frspacing_m <dbl>,\n#   ED_gas_pedal_pos <dbl>, ED_brake_pedal_force_kg <dbl>, tau_inv <dbl>, and\n#   abbreviated variable names 1: LV_length_m, 2: LV_width_m,\n#   3: visual_angle_W, 4: visual_angle_H, 5: ED_speed_mps, 6: LV_speed_mps\n# i Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names\n\n\n\n\n\nAs discussed in the previous blogpost, I had to adjust the coordinates to make one car appear approaching another car. So, we estimate the first and last coordinates in the data to do that.\n\n# Largest x coordinate of following vehicle------------------\n  first_ed_x_coord <- df %>% pull(ED_x_m) %>% range() %>% tail(1)\n  last_ed_x_coord <- df %>% pull(ED_x_m) %>% range() %>% head(1)"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#top-view",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#top-view",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Top view",
    "text": "Top view\n\n# animation of position---------------------------------------\n  ani_car_b <- ggplot(df) +\n    geom_car(aes(x=abs(ED_x_m-first_ed_x_coord), \n                 y=first_ed_x_coord-last_ed_x_coord, length=4.64, width=2.078, fill=\"ed\")) +\n    geom_text(aes(x=abs(ED_x_m-first_ed_x_coord), y = (first_ed_x_coord-last_ed_x_coord)+3,\n                  label = paste(\"Following Car\\nSpeed =\", ED_speed_mps, \"m/s\")),\n              color=\"darkgray\"\n    ) +\n    geom_car(aes(x=abs(LV_x_m-first_ed_x_coord), y=first_ed_x_coord-last_ed_x_coord, length=LV_length_m,\n                 width=LV_width_m, fill=\"lv\")) +\n    geom_text(aes(x=abs(LV_x_m-first_ed_x_coord), y = (first_ed_x_coord-last_ed_x_coord)+3, \n                  label = paste(\"Lead Car\\nSpeed =\", LV_speed_mps, \"m/s\")),\n              color=\"darkgray\") +\n    \n    geom_segment(aes(x = abs(ED_x_m-first_ed_x_coord)+(0.5*4.64),\n                     xend = abs(LV_x_m-first_ed_x_coord)-(0.5*LV_length_m),\n                     y = first_ed_x_coord-last_ed_x_coord,\n                     yend= first_ed_x_coord-last_ed_x_coord), \n                 arrow = arrow(length = unit(0.1, \"inches\"), ends = \"both\")) +\n    geom_text(aes(x= ((abs(ED_x_m-first_ed_x_coord)+(0.5*4.64))+(abs(LV_x_m-first_ed_x_coord)-(0.5*LV_length_m)))/2, y = (first_ed_x_coord-last_ed_x_coord)+3.5, \n                  label = paste(\"Spacing =\", LV_frspacing_m, \"m\")),\n              color=\"darkgray\") +\n    \n    coord_equal(ratio=0.7) +\n    scale_fill_manual(values = c(\"blue\", \"black\")) +\n    theme_void() +\n    theme(legend.position = \"none\",\n          axis.text = element_blank(),\n          axis.title = element_blank(),\n          axis.ticks = element_blank()\n    ) +\n    transition_manual(Time_s) +\n    ease_aes() +\n    view_follow()\n\nani_car_b\n\nnframes and fps adjusted to match transition"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#pedal-positions-and-inverse-time-to-collision",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#pedal-positions-and-inverse-time-to-collision",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Pedal positions and inverse time-to-collision",
    "text": "Pedal positions and inverse time-to-collision\nThe following animation shows how the gas and brake pedal positions change over time. The variable tau-inverse represents the inverse of time-to-collision (seconds until collision happens if cars don’t change their speeds).\n\n# animation of pedals/looming---------------------------------------\npedals_pos_b <- ggplot(data = df,\n                         mapping = aes(x = Time_s)) +\n    geom_line(aes(y = tau_inv*10), color = \"black\") +\n    geom_text(aes(y = tau_inv*10,\n                  label = paste(\"tau-inv =\", round(tau_inv, 2))), color = \"black\",\n              size = 5) +\n    geom_area(aes(y = tau_inv*10), fill = \"gray\",\n              position = \"identity\", alpha=0.6)+\n    \n    geom_line(aes(y = scale(ED_gas_pedal_pos)), color = \"darkgreen\") +\n    geom_text(aes(y = scale(ED_gas_pedal_pos)),\n              label = \"Gas Pedal\", color = \"darkgreen\") +\n    \n    geom_line(aes(y = scale(ED_brake_pedal_force_kg)), color = \"red\") +\n    geom_text(aes(y = scale(ED_brake_pedal_force_kg)),\n              label = \"Brake Pedal\", color = \"red\") +\n    \n    geom_text(x= 10, y = 4, \n              aes(label = paste(\"Brake Pedal Force =\", \n                                round(ED_brake_pedal_force_kg), \"kg\"))) +\n    theme_void() +\n    transition_reveal(Time_s)\n  \n\n pedals_pos_b"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#drivers-front-view",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#drivers-front-view",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Driver’s front view",
    "text": "Driver’s front view\nThe following animation shows what the driver in the following car sees from the windscreen. It represents how the image of the lead vehicle grows on the following driver’s retina.\n\n# animation of car rear---------------------------------------\nani_retina_b <- ggplot(df ) +\n    geom_car_rear(aes(x=0, y=0, length=visual_angle_W,\n                      width=visual_angle_H), fill=\"black\") +\n    theme_void() +\n    theme(axis.text = element_blank(),\n          axis.title = element_blank(),\n          axis.ticks = element_blank())+\n    coord_fixed(ratio = 0.7) +\n    transition_manual(Time_s) \n  \n ani_retina_b\n\nnframes and fps adjusted to match transition"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#rendering-animations-and-saving-them",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#rendering-animations-and-saving-them",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Rendering animations and saving them",
    "text": "Rendering animations and saving them\nNow that the three animations are created, we can render them using gganimate::animate function. Without doing this, the animations are rendered every time we call them.\n\n# Rendering gifs-------------------------------------------------\n  a_gif <- animate(ani_car_b, height = 3, width = 8, end_pause = 15,\n                   units = \"in\", res = 150, fps = 5, duration=10)\n  b_gif <- animate(pedals_pos_b, fps = 5, duration=10,\n                   height = 3.5, width = 4.5, end_pause = 15,\n                   units = \"in\", res = 150)\n  c_gif <- animate(ani_retina_b, fps = 5, duration=10,\n                   height = 3.5, width = 3.5, end_pause = 15,\n                   units = \"in\", res = 150)\n  \n## saving  \nanim_save(filename = \"a_gif.gif\",\n          animation = a_gif)\nanim_save(filename = \"b_gif.gif\",\n          animation = b_gif)\nanim_save(filename = \"c_gif.gif\",\n          animation = c_gif)"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#reading-the-gif-images",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#reading-the-gif-images",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Reading the gif images",
    "text": "Reading the gif images\n\n# Convertig the rendered gifs to magick class-------------\n  a_mgif <- image_read(path = \"a_gif.gif\")\n  b_mgif <- image_read(path = \"b_gif.gif\")\n  c_mgif <- image_read(path = \"c_gif.gif\")\n\nBy the reading the saved gif images (animations) using magick::image_read(), we convert the animation from the gif_image class to magick-image class."
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#aligning-the-animations",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#aligning-the-animations",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Aligning the animations",
    "text": "Aligning the animations\nFinally, we combine the animations using a for-loop and magick::image_append:\n\n# Aligning gifs-------------------------------------------------\n  bc_gif <- image_append(c(b_mgif[1], c_mgif[1]), stack = FALSE)\n  for(i in 2:50){\n    combined <- image_append(c(b_mgif[i], c_mgif[i]), stack = FALSE)\n    bc_gif <- c(bc_gif, combined)\n  }\n\n  new_gif <- image_append(c(a_mgif[1], bc_gif[1]), stack = TRUE)\n  for(i in 2:50){\n    combined <- image_append(c(a_mgif[i], bc_gif[i]), stack = TRUE)\n    new_gif <- c(new_gif, combined)\n  }\n\n new_gif"
  },
  {
    "objectID": "posts/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package.html",
    "href": "posts/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package.html",
    "title": "How to fit different models on a dataset (the power of purrr)?",
    "section": "",
    "text": "I wanted to fit multiple models on a dataset in R, and I had no idea how to do that efficiently. So, I turned to twitter and got an amazing reply:\n\n\nLike this? pic.twitter.com/uGcKpVGLbH\n\n— Daniel Anderson (@datalorax_) April 24, 2019\n\n\nPurrrfect!! Thank you Daniel.\n\n\nI created a short tutorial to show the steps for fitting a model to multiple datasets or fitting multiple models to a single dataset:"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "",
    "text": "I want to find which countries are the most similar to each other in terms of their life expectancy, population and GDP over the years"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-1-choose-the-variables-you-want-to-use-in-calculating-the-dtw-dissimilarity-score",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-1-choose-the-variables-you-want-to-use-in-calculating-the-dtw-dissimilarity-score",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Step 1) Choose the variables you want to use in calculating the dtw dissimilarity score",
    "text": "Step 1) Choose the variables you want to use in calculating the dtw dissimilarity score\nHere, I am choosing to use only the countries in Asia, and I am going to use life expectancy, population and GDP for the estimation of dtw score.\nAlso, it is important to scale all variables as right now they are in different scales. You can also scale them in the function that does the clustering.\n\n### Function to scale a variable\nscale_this <- function(x){\n  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)\n}\n\n\ndf <- gapminder %>% \n  filter(continent == \"Asia\") %>% # countries in Asia only\n  group_by(country) %>%           # scaling the vars for each country\n  mutate(lifeExp = scale_this(lifeExp),\n         pop = scale_this(pop),\n         gdpPercap = scale_this(gdpPercap)\n  ) %>%\n  ungroup()\n\ndf\n\n# A tibble: 396 x 6\n   country     continent  year lifeExp     pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>   <dbl>     <dbl>\n 1 Afghanistan Asia       1952  -1.70  -1.04      -0.215\n 2 Afghanistan Asia       1957  -1.40  -0.925      0.168\n 3 Afghanistan Asia       1962  -1.08  -0.781      0.466\n 4 Afghanistan Asia       1967  -0.678 -0.602      0.310\n 5 Afghanistan Asia       1972  -0.273 -0.386     -0.579\n 6 Afghanistan Asia       1977   0.188 -0.133     -0.153\n 7 Afghanistan Asia       1982   0.466 -0.414      1.62 \n 8 Afghanistan Asia       1987   0.656 -0.275      0.460\n 9 Afghanistan Asia       1992   0.823  0.0695    -1.42 \n10 Afghanistan Asia       1997   0.840  0.900     -1.55 \n# ... with 386 more rows\n# i Use `print(n = ...)` to see more rows"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-2-split-the-data-by-each-country-and-convert-to-a-matrix",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-2-split-the-data-by-each-country-and-convert-to-a-matrix",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Step 2) Split the data by each country and convert to a matrix",
    "text": "Step 2) Split the data by each country and convert to a matrix\nThis is required by the dtwclust package.\n\ndf_matrix <- df %>% \n  split(.$country, drop = T) %>% \n  purrr::map(~ .x[, c(\"lifeExp\",    # names of all vars\n                       \"pop\",\n                       \"gdpPercap\"\n                      )]) %>% \n  purrr::map(as.matrix) \n\n### printing out df shows the matrices by country\nstr(df_matrix[[1]])\n\n num [1:12, 1:3] -1.702 -1.402 -1.075 -0.678 -0.273 ...\n - attr(*, \"dimnames\")=List of 2\n  ..$ : NULL\n  ..$ : chr [1:3] \"lifeExp\" \"pop\" \"gdpPercap\""
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-3-use-the-tsclust-function-from-the-dtwclust-package-for-clustering-using-the-dtw-score",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-3-use-the-tsclust-function-from-the-dtwclust-package-for-clustering-using-the-dtw-score",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Step 3) Use the tsclust function from the dtwclust package for clustering using the dtw score",
    "text": "Step 3) Use the tsclust function from the dtwclust package for clustering using the dtw score\nBoth steps are done using a single function:\n\nclusters_gp <- df_matrix %>% \n  tsclust(., \n          k = 8L,                 # assuming clusters\n          distance = \"dtw_basic\", # this is dtw score\n          seed = 390,             # to reproduce results\n          type=\"hierarchical\",    # type of clustering\n          control = hierarchical_control(method = \"ward.D\")) # method in hc\n\nclusters_gp\n\nhierarchical clustering with 8 clusters\nUsing dtw_basic distance\nUsing PAM (Hierarchical) centroids\nUsing method ward.D \n\nTime required for analysis:\n   user  system elapsed \n   0.04    0.00    0.05 \n\nCluster sizes with average intra-cluster distance:\n\n  size  av_dist\n1    1 0.000000\n2    3 5.422677\n3    6 8.436258\n4   13 7.564260\n5    2 6.603003\n6    2 8.962541\n7    5 9.061991\n8    1 0.000000"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#a-dendrogram-tree",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#a-dendrogram-tree",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "A dendrogram (tree)",
    "text": "A dendrogram (tree)\n\nfviz_dend(clusters_gp, k = 8, # Cut the tree in groups\n          cex = 0.5, # label size\n          color_labels_by_k = TRUE, # color labels by groups\n          rect = TRUE, # Add rectangle around groups\n          horiz = TRUE, # Make the tree horizontal\n          ylab = \"DTW score\",\n          palette = \"uchicago\")\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead."
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#labeling-countries-based-on-clusters-and-visualizing-each-variable",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#labeling-countries-based-on-clusters-and-visualizing-each-variable",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Labeling countries based on clusters and visualizing each variable",
    "text": "Labeling countries based on clusters and visualizing each variable\nWe are now joining the estimated groups with the data:\n\nGps <- as.data.frame(cutree(clusters_gp, k = 8)) # num of clusters\ncolnames(Gps) <- \"Gp\"\nGps$country <- row.names(Gps)\nrow.names(Gps) <- NULL\n\n\n\n## Getting the clustering info into the original data\ngapminder_Asia <- gapminder %>% \n  filter(continent == \"Asia\") %>% \n  left_join(x=., y=Gps, by = \"country\")\n\ngapminder_Asia\n\n# A tibble: 396 x 7\n   country     continent  year lifeExp      pop gdpPercap    Gp\n   <chr>       <fct>     <int>   <dbl>    <int>     <dbl> <int>\n 1 Afghanistan Asia       1952    28.8  8425333      779.     1\n 2 Afghanistan Asia       1957    30.3  9240934      821.     1\n 3 Afghanistan Asia       1962    32.0 10267083      853.     1\n 4 Afghanistan Asia       1967    34.0 11537966      836.     1\n 5 Afghanistan Asia       1972    36.1 13079460      740.     1\n 6 Afghanistan Asia       1977    38.4 14880372      786.     1\n 7 Afghanistan Asia       1982    39.9 12881816      978.     1\n 8 Afghanistan Asia       1987    40.8 13867957      852.     1\n 9 Afghanistan Asia       1992    41.7 16317921      649.     1\n10 Afghanistan Asia       1997    41.8 22227415      635.     1\n# ... with 386 more rows\n# i Use `print(n = ...)` to see more rows"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#plotting-each-variable-by-group",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#plotting-each-variable-by-group",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Plotting each variable by group",
    "text": "Plotting each variable by group\nFollowing plots show the time-series of life expectancy, population and GDP by group:\n\n### Select 15 countries at random to label on plot\nset.seed(123)\n\nselected_countries <- gapminder_Asia %>% \n  group_by(Gp) %>% \n  select(country) %>% \n  unique() %>% \n  sample_n(size = 4, replace = TRUE) %>% \n  ungroup() %>% \n  pull(country) %>% \n  unique()\n\nAdding missing grouping variables: `Gp`\n\nsc_data <- gapminder_Asia %>% \n  filter(year == 1982,\n         country %in% selected_countries)\n\n\n\n### lifeExp\nggplot(data = gapminder_Asia,\n       aes(x = year, y = lifeExp)) +\n  geom_line(aes(group=country), color = \"grey\") +\n  facet_wrap(~ Gp) +\n  geom_line(data = gapminder_Asia %>% \n              filter(country %in% selected_countries),\n            aes(group=country)) +\n  geom_text_repel(data = sc_data,\n            aes(label = country),\n            box.padding = 1,\n            nudge_x = .15,\n            nudge_y = .5,\n            arrow = arrow(length = unit(0.015, \"npc\")),\n            hjust = 0\n            ) +\n  theme_bw()\n\n\n\n### pop\nggplot(data = gapminder_Asia,\n       aes(x = year, y = pop)) +\n  geom_line(aes(group=country), color = \"grey\") +\n  facet_wrap(~ Gp, scales = \"free_y\") +\n  geom_line(data = gapminder_Asia %>% \n              filter(country %in% selected_countries),\n            aes(group=country)) +\n  geom_text_repel(data = sc_data,\n                  aes(label = country),\n                  box.padding = 1,\n                  nudge_x = .15,\n                  nudge_y = .5,\n                  arrow = arrow(length = unit(0.015, \"npc\")),\n                  hjust = 0\n  ) +\n  theme_bw()\n\n\n\n### gdpPercap\npp <- ggplot(data = gapminder_Asia,\n       aes(x = year, y = gdpPercap)) +\n  geom_line(aes(group=country), color = \"grey\") +\n  facet_wrap(~ Gp, scales = \"free_y\") +\n  geom_line(data = gapminder_Asia %>% \n              filter(country %in% selected_countries),\n            aes(group=country)) +\n  geom_text_repel(data = sc_data,\n                  aes(label = country),\n                  box.padding = 1,\n                  nudge_x = .15,\n                  nudge_y = .5,\n                  arrow = arrow(length = unit(0.015, \"npc\")),\n                  hjust = 0\n  ) +\n  theme_bw()\n\nggsave(\"pp.png\", plot=pp, dpi=600)\n\nSaving 7 x 5 in image"
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html",
    "title": "Elevation Maps in R",
    "section": "",
    "text": "In this post I show you how to create aesthetically pleasant and useful maps in R using ground elevation data."
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#getting-the-elevation-data-in-r",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#getting-the-elevation-data-in-r",
    "title": "Elevation Maps in R",
    "section": "Getting the Elevation Data in R",
    "text": "Getting the Elevation Data in R\nI got the elevation data from Geohub which provides the data for Ontario, Canada in the .tif format. The .tif file type can be easily imported in R using the raster package. If you want to use United States data, the elevatr R package can help with that.\nI have downloaded 2 files for Ontario, one each for north and south Ontario, and then unzipped them. Let’s start by loading the libraries and importing the data.\n\n# Load Libraries ----------------------------------------------------------\n\nsuppressPackageStartupMessages( library(raster) )\nsuppressPackageStartupMessages( library(tidyverse) )\nsuppressPackageStartupMessages( library(ggridges) )\nsuppressPackageStartupMessages( library(rayshader) )\nsuppressPackageStartupMessages( library(gganimate) )\nsuppressPackageStartupMessages( library(sf) )\n\n\n\n\n# Load Data ---------------------------------------------------------------\nont_s <- raster(\"PDEM_South.tif\")\n# ont_n <- raster(here::here(\"PDEM_North.tif\"))\n\nNote that I used here::here() to get my file paths. Let’s see what’s in them:\n\nont_s\n\nclass      : RasterLayer \ndimensions : 31655, 55685, 1762708675  (nrow, ncol, ncell)\nresolution : 30, 30  (x, y)\nextent     : 151020, 1821570, 11620380, 12570030  (xmin, xmax, ymin, ymax)\ncrs        : +proj=lcc +lat_0=0 +lon_0=-85 +lat_1=44.5 +lat_2=53.5 +x_0=930000 +y_0=6430000 +datum=NAD83 +units=m +no_defs \nsource     : PDEM_South.tif \nnames      : PDEM_South \n\n# ont_n\n\nThey are clearly raster file types. You can see in the dimensions section that the number of cells (i.e. number of data points) is quite a large number for both layers. This means that if we try to plot these data with a typical RAM size, say 8GB, we’d have a bad time1. So, to create maps we’d need to decrease the size of these raster layers.\nBefore going to the next step, an important thing to note here is that the crs section above indicates that the units of the x, y and elevation coordinates are meters. The elevation is stored here under the names PDEM_South and PDEM_North in the two raster layers."
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#slimming-down-the-raster-data",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#slimming-down-the-raster-data",
    "title": "Elevation Maps in R",
    "section": "Slimming Down the Raster Data",
    "text": "Slimming Down the Raster Data\nThe sampleRegular function from the raster package lets you take a sample of the original raster data by specifying the size argument. I experimented with different sizes, and was satisfied with size=50000, as it provided a good visual quality in the maps. The last argument here is asRaster that returns a raster data when TRUE.\nOnce we get a reduced raster data, we use the rayshader::raster_to_matrix() function to put all the elevation values in a 2D matrix where the 2 dimensions are x and y coordinates. Following shows the results (only the first 5 rows and columns for each layer):\n\nont_s_m <- ont_s %>% \n  raster::sampleRegular(ont_s, size=50000, asRaster=TRUE) %>%\n  rayshader::raster_to_matrix()\n\nont_s_m[1:5, 1:5]\n\n         [,1]     [,2]     [,3]     [,4]     [,5]\n[1,]       NA 345.7590 343.8626 339.1616       NA\n[2,] 341.2442 344.7713 351.7452 340.4780 326.4015\n[3,] 346.9645 350.9861 349.9320 330.7751 336.5002\n[4,] 355.3123 357.0607 337.0629 333.1272 338.1620\n[5,] 358.0299 358.2284 334.0108 329.6138 329.7867\n\n# ont_n_m <- ont_n %>% \n#   raster::sampleRegular(ont_n, size=50000, asRaster=TRUE) %>%\n#   rayshader::raster_to_matrix()\n# \n# ont_n_m[1:5, 1:5]"
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#d-raster-maps-with-rayshader",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#d-raster-maps-with-rayshader",
    "title": "Elevation Maps in R",
    "section": "3D Raster Maps with Rayshader",
    "text": "3D Raster Maps with Rayshader\nWe use the awesome rayshader package here to plot the raster map in 3D.\n\nont_s_m %>%\n  sphere_shade(texture = \"desert\") %>%\n  add_shadow(ray_shade(ont_s_m, zscale = 30), 0.5) %>%\n  add_shadow(ambient_shade(ont_s_m), 0) %>%\n  plot_3d(ont_s_m, zscale = 10, fov = 0,\n          theta = 0, zoom = 0.75, phi = 70,\n          windowsize = c(1000, 800),\n          solid=FALSE)\n\nSys.sleep(0.6)\nrender_snapshot(clear=T, title_text = \"Ontario (South)\",\n                filename=\"ont_s.png\")\n\nrgl::rgl.close()\n\n## For some reason, rayshader is not rendering the snapshot\n## of this map."
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#creating-ridgeline-maps",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#creating-ridgeline-maps",
    "title": "Elevation Maps in R",
    "section": "Creating Ridgeline Maps",
    "text": "Creating Ridgeline Maps\nRaster maps are beautiful but take long time to render. Another technique that can show the elevation data very effectively is a ridgeline plot. I was previously familiar with the ggridges package but was recently reminded of it when I saw the ridgeline plots app made by Andrei Kashcha. So, I decided to use elevation height in the ggridges::geom_ridgeline() function.\nBut a ridgeline plot uses 3 arguments, x, y, and height. So, to proceed, we need to extract these coordinates from the raster files. Again, we use the raster::sampleRegular function for slimming the data, but also use the xy=TRUE option to get the three coordinates:\n\n## Sample 10000 values\ndf_s <- data.frame(sampleRegular(ont_s, 10000, xy=TRUE))\n# df_n <- data.frame(sampleRegular(ont_n, 10000, xy=TRUE))\n\n\n## Rename to 'elevation'\ndf_s <- df_s %>% \n  rename(elevation = PDEM_South)\n\n# df_n <- df_n %>% \n#   rename(elevation = PDEM_North)\n\n\n## Combine the two\ndf <- df_s#bind_rows(df_s, df_n)\n\nhead(df)\n\n       x        y elevation\n1 157335 12563715  341.1952\n2 169995 12563715  354.5818\n3 182655 12563715  364.6080\n4 195285 12563715  336.9090\n5 207945 12563715  328.2127\n6 220605 12563715  320.1098\n\n\nNote that elevation above is not completely NA (you are seeing the first 6 rows only).\n\nMy attempts to use ggridges::geom_ridgeline() were not successful. Instead, the other function, ggridges::geom_density_ridges is what can effectively generate the nice elevation lines for creating the 3D effect that Andrei showed. I learnt this from Travis M. White’s blogpost. I also found great tips for theming the map.\n\n\nPlots\nThe data is ready now, back to making the maps. A first try:\n\nggplot() +\n  geom_density_ridges(data = df,\n                      aes(x, y, \n                          group=y,\n                          height = elevation),\n                      stat = \"identity\",\n                      scale=20) +\n  theme_void() \n\n\n\n\nSee the 3D effect?\nThe scale argument controls the overlap between the ridgelines. I experimented with different values and settled with 20.\nNow with a dark theme:\n\nggplot() +\n  geom_density_ridges(data = df,\n                      aes(x, y, \n                          group=y,\n                          height = elevation),\n                      stat = \"identity\",\n                      scale=20,\n                      fill=\"black\",\n                      color=\"white\") +\n  scale_x_continuous(name = \"Ontario\") +\n  theme_void() +\n  theme(\n             panel.background = element_rect(fill = \"black\"),\n            \n             plot.background = element_rect(fill = \"black\"),\n           \n             axis.title.x = element_text(colour = 'white', \n                                         size = 18))\n\n\n\n\nFor some reason, this reminded me of neon signs. So, I got an idea!"
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#animating-the-ridgeline-map",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#animating-the-ridgeline-map",
    "title": "Elevation Maps in R",
    "section": "Animating the Ridgeline Map",
    "text": "Animating the Ridgeline Map\nLet’s animate the map with colors. For doing so, I create 2 more copies of the data df and then give one color to each (there may be a better way to do this). Then I use transition_reveal to color the lines turn by turn:\n\ncolos = rep(c(\"red\", \"yellow\", \"green\"), each = nrow(df))\n\nretro <- bind_rows(df, df, df) %>% \n  mutate(colorz = colos)\n\nani1 <- ggplot(data = retro ,\n       aes(x, y, \n           group=y,\n           height = elevation))+\n  geom_density_ridges(stat = \"identity\",\n                      scale=20,\n                      fill=\"black\",\n                      aes(color=colorz)) +\n  scale_x_continuous(name = \"Ontario\") +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    panel.background = element_rect(fill = \"black\"),\n    \n    plot.background = element_rect(fill = \"black\"),\n    \n    axis.title.x = element_text(colour = 'white', \n                                size = 18)) +\n    transition_states(colorz,\n                    transition_length = 2,\n                    state_length = 1)\n\nani1\n\n\n\n\nOf course, we can also animate by x or y dimensions:\n\nani2 <- ggplot(data = df,\n       aes(x, y, \n           group=y,\n           height = elevation))+\n  geom_density_ridges(stat = \"identity\",\n                      scale=8,\n                      fill=\"black\",\n                      color = \"white\") +\n  scale_x_continuous(name = \"Ontario\") +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    panel.background = element_rect(fill = \"black\"),\n    \n    plot.background = element_rect(fill = \"black\"),\n    \n    axis.title.x = element_text(colour = 'white', \n                                size = 18)) + \n  transition_manual(x, cumulative = T) + \n  ease_aes('linear')\n\n\nani2\n\n\n\n\nThis ends the blogpost. I hope you’d find something useful here for your mapping needs."
  },
  {
    "objectID": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html",
    "href": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html",
    "title": "Autocomplete Character/Factor values in RStudio",
    "section": "",
    "text": "This post is based on Ayush Patel’s post that describes the use of the patch package that lets you choose from a menu of character/factor values in RStudio."
  },
  {
    "objectID": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html#autocomplete-in-action",
    "href": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html#autocomplete-in-action",
    "title": "Autocomplete Character/Factor values in RStudio",
    "section": "Autocomplete in action",
    "text": "Autocomplete in action\nNow we can easily select the desired character/factor value from the autocomplete menu. Let’s first load a data set and see the factor values in it.\n\ndata(\"chickwts\")\n\nchickwts\n\n   weight      feed\n1     179 horsebean\n2     160 horsebean\n3     136 horsebean\n4     227 horsebean\n5     217 horsebean\n6     168 horsebean\n7     108 horsebean\n8     124 horsebean\n9     143 horsebean\n10    140 horsebean\n11    309   linseed\n12    229   linseed\n13    181   linseed\n14    141   linseed\n15    260   linseed\n16    203   linseed\n17    148   linseed\n18    169   linseed\n19    213   linseed\n20    257   linseed\n21    244   linseed\n22    271   linseed\n23    243   soybean\n24    230   soybean\n25    248   soybean\n26    327   soybean\n27    329   soybean\n28    250   soybean\n29    193   soybean\n30    271   soybean\n31    316   soybean\n32    267   soybean\n33    199   soybean\n34    171   soybean\n35    158   soybean\n36    248   soybean\n37    423 sunflower\n38    340 sunflower\n39    392 sunflower\n40    339 sunflower\n41    341 sunflower\n42    226 sunflower\n43    320 sunflower\n44    295 sunflower\n45    334 sunflower\n46    322 sunflower\n47    297 sunflower\n48    318 sunflower\n49    325  meatmeal\n50    257  meatmeal\n51    303  meatmeal\n52    315  meatmeal\n53    380  meatmeal\n54    153  meatmeal\n55    263  meatmeal\n56    242  meatmeal\n57    206  meatmeal\n58    344  meatmeal\n59    258  meatmeal\n60    368    casein\n61    390    casein\n62    379    casein\n63    260    casein\n64    404    casein\n65    318    casein\n66    352    casein\n67    359    casein\n68    216    casein\n69    222    casein\n70    283    casein\n71    332    casein\n\n\nNow, do a filter on the feed:\n\nAnd the result is:\n\nchickwts %>% \n  filter(feed == \"linseed\")\n\n   weight    feed\n1     309 linseed\n2     229 linseed\n3     181 linseed\n4     141 linseed\n5     260 linseed\n6     203 linseed\n7     148 linseed\n8     169 linseed\n9     213 linseed\n10    257 linseed\n11    244 linseed\n12    271 linseed"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html",
    "title": "Making a History Table of Discover Canada in R",
    "section": "",
    "text": "Discover Canada is a study guide that is a required read for anyone preparing for the Canadian citizenship test. It contains information on Canadian government, culture and geography.\nThere is also a lot of history sprinkled throughout the text, containing the exact year when something important happened. For example, the current border between Canada and The United States of America was partly a result of the 1812 war between the two countries."
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#can-i-use-r-to-create-a-history-timeline",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#can-i-use-r-to-create-a-history-timeline",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Can I use R to create a history timeline?",
    "text": "Can I use R to create a history timeline?\nAs a new reader, trying to remember all of the Canadian histoy seems very daunting. I personally prefer a timeline with year and what happened information. So, I initially thought to create something like that by hand, but then:\n\nI recalled that Discover Canada is also available as a pdf and I could potentially import it in R as text\nI had heard the term corpus used for text documents in R, and thought that I could maybe convert the imported text into a corpus. A recent R Ladies webinar showed exactly how (Thank you R-Ladies Tunis!)\nWith text in R, I could use the tidytext package to extract the sentences and then get the history by years\nFinally, I could create a table with history in each year in increasing order using reactable package. My starting point here was Tom Mock’s blog (thanks Tom!)"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-1-from-pdf-to-dataframe",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-1-from-pdf-to-dataframe",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Step 1: From pdf to dataframe",
    "text": "Step 1: From pdf to dataframe\nI started by loading the pdftools and quanteda libraries for reading the Discover Canada pdf file and converting it into a corpus.\n\nsuppressPackageStartupMessages(library(pdftools))\nsuppressPackageStartupMessages(library(quanteda)) \n\nI first downloaded the large print pdf file from the Discover Canada website. Following shows the page 13 from the pdf:\n\n\n\nPage 13 from the Large Print pdf of Discover Canada\n\n\nNext, I read this file in R:\n\npdf_text <- pdf_text(pdf = \"discover-large.pdf\")\n\nhead(pdf_text, 3)\n\n[1] \"             STUDY GUIDE\\r\\n           Discover Canada\\r\\nThe Rights and Responsibilities of Citizenship\\r\\n          LARGE PRINT\\r\\n\"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n[2] \"     2\\r\\n\\t\\r  \\r\\n\"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n[3] \"The Oath of Citizenship\\r\\nI swear (or affirm)\\r\\nThat I will be faithful\\r\\nAnd bear true allegiance\\r\\nTo Her Majesty Queen Elizabeth the Second\\r\\nQueen of Canada\\r\\nHer Heirs and Successors\\r\\nAnd that I will faithfully observe\\r\\nThe laws of Canada\\r\\nAnd fulfil my duties as a Canadian citizen.\\r\\nLe serment de citoyenneté\\r\\nJe jure (ou j’affirme solennellement)\\r\\nQue je serai fidèle\\r\\nEt porterai sincère allégeance\\r\\nà Sa Majesté la Reine Elizabeth Deux\\r\\nReine du Canada\\r\\nÀ ses héritiers et successeurs\\r\\nQue j’observerai fidèlement les lois du Canada\\r\\nEt que je remplirai loyalement mes obligations\\r\\nde citoyen canadien.\\r\\n                                   3\\r\\n\\t\\r  \\r\\n\" \n\n\nThe next step was to convert the raw text into a corpus. This is possible with the corpus() function from the quanteda package:\n\ndc_corpus <- corpus(pdf_text)\n\ndocvars(dc_corpus)\n\ndata frame with 0 columns and 129 rows\n\n\nThe quanteda::docvars() function lets you find the existing variables and create new variables for the documents in a corpus. There were 129 text “documents” in dc_corpus (you can find it with length(dc_corpus)). We know that there is only 1 document that I am using here, but the pdftools::pdftext() function split the original text into 129 parts. That’s why the corpus now has 129 documents.\n\nInterlude: Tokenization and Visualization of Text Data\nNow that the data is living in a corpus, there is a lot that I can do in terms of text analysis. For instance, this awesome post by the R-Ladies presenter, Cosima Meyer introduces the terms for natural language processing and also shows how to clean and visualize text data. Based on that code, I produced a word cloud in three steps below, all powered by the quanteda package:\n\nPre-process the text by removing punctuation, symbols and URL, and splitting the hyphenated words. This pre-processed result is called as tokens.\n\n\n# Text pre-processing\ndc_tokens <- tokens(\n    # Takes the corpus\n    dc_corpus,\n    # Remove punctuation\n    remove_punct = TRUE,\n    # Remove symbols\n    remove_symbols = TRUE,\n    # Remove URL\n    remove_url = TRUE,\n    # Split up hyphenated words\n    split_hyphens = TRUE\n  )\n\n\nhead(dc_tokens, 3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"STUDY\"            \"GUIDE\"            \"Discover\"         \"Canada\"          \n [5] \"The\"              \"Rights\"           \"and\"              \"Responsibilities\"\n [9] \"of\"               \"Citizenship\"      \"LARGE\"            \"PRINT\"           \n\ntext2 :\n[1] \"2\"\n\ntext3 :\n [1] \"The\"         \"Oath\"        \"of\"          \"Citizenship\" \"I\"          \n [6] \"swear\"       \"or\"          \"affirm\"      \"That\"        \"I\"          \n[11] \"will\"        \"be\"         \n[ ... and 87 more ]\n\n\n\nCreate a document-feature matrix (DFM). DFM estimates the frequency of each word (‘feature’) across all the text components (‘documents’). While creating DFM you can also stem words. Stemming refers to finding the common root of several words. For example, government and governor have the same root govern. Moreover, you can remove the stopwords that are common words in the language e.g. the, are, etc.\n\n\n# Calculate a document-feature matrix (DFM)\n\ndc_dfm <- dfm(\n  # Take the token object\n  dc_tokens,\n  # Lower the words\n  tolower = TRUE,\n  # Get the stem of the words\n  stem = TRUE,\n  # Remove stop words\n  remove = stopwords(\"english\")\n)\n\ndc_dfm\n\nDocument-feature matrix of: 129 documents, 3,008 features (97.7% sparse).\n       features\ndocs    studi guid discov canada right respons citizenship larg print 2\n  text1     1    1      1      1     1       1           1    1     1 0\n  text2     0    0      0      0     0       0           0    0     0 1\n  text3     0    0      0      4     0       0           1    0     0 0\n  text4     0    0      0      5     1       0           1    0     0 0\n  text5     0    0      0      5     2       2           4    0     0 0\n  text6     0    1      0      2     2       1           1    0     0 0\n[ reached max_ndoc ... 123 more documents, reached max_nfeat ... 2,998 more features ]\n\n\n\nCreate a wordcloud:\n\n\nsuppressPackageStartupMessages(library(wesanderson))\n\ntextplot_wordcloud(\n  # Load the DFM object\n  dc_dfm,\n  # Define the minimum number the words have to occur\n  min_count = 3,\n  # Define the maximum number the words can occur\n  max_words = 500,\n  # Define a color\n  color = wes_palette(\"Royal1\")\n  \n)\n\n\n\n\nAs expected, canada was the most common word across all the paragraphs of text.\nGoing back to our task of creating a dataframe out of the corpus, the following code shows how to do that (thanks to this answer on stackoverflow):\n\nsuppressPackageStartupMessages(library(tidyverse))\n# Corpus to dataframe\ndc_df <- data.frame(text = sapply(dc_corpus, as.character), \n           stringsAsFactors = FALSE, row.names = NULL) %>% \n         as_tibble()\n\nhead(dc_df, 3)\n\n# A tibble: 3 x 1\n  text                                                                          \n  <chr>                                                                         \n1 \"             STUDY GUIDE\\n           Discover Canada\\nThe Rights and Respons~\n2 \"     2\\n\\t\\n  \\n\"                                                            \n3 \"The Oath of Citizenship\\nI swear (or affirm)\\nThat I will be faithful\\nAnd b~"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-2-split-the-text-paragraph-in-each-row-into-sentences",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-2-split-the-text-paragraph-in-each-row-into-sentences",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Step 2: Split the text paragraph in each row into sentences",
    "text": "Step 2: Split the text paragraph in each row into sentences\nI used the tidytext package for this step:\n\nsuppressPackageStartupMessages(library(tidytext))\n## divide into sentences\ndc_df_sent <- dc_df %>% \n  unnest_tokens(output = sentence, input = text, token = \"sentences\")\n\nhead(dc_df_sent, 3)\n\n# A tibble: 3 x 1\n  sentence                                                                      \n  <chr>                                                                         \n1 study guide            discover canada the rights and responsibilities of cit~\n2 2                                                                             \n3 the oath of citizenship i swear (or affirm) that i will be faithful and bear ~"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-3-find-the-sentences-containing-years",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-3-find-the-sentences-containing-years",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Step 3: Find the sentences containing years",
    "text": "Step 3: Find the sentences containing years\nI found all those sentences that contained a four-digit number that indicated a year in the text. Then I filtered out all other sentences and sorted the dataframe by year:\n\n## Find which sentence has a 4 digit number\ndc_df_year <- dc_df_sent %>% \n  mutate(\n    has_a_num = str_detect(string = sentence, pattern = \"[[:digit:]]{4}\")\n  ) %>% \n  filter(has_a_num == TRUE) %>% \n  mutate(\n    year = str_extract(string = sentence, pattern = \"[[:digit:]]{4}\") %>% \n      as.numeric()\n  ) %>% \n  select(year, sentence) %>% \n  arrange(year) \n\n\nhead(dc_df_year, 2)\n\n# A tibble: 2 x 2\n   year sentence                                                                \n  <dbl> <chr>                                                                   \n1  1215 together, these secure for canadians an 800-year old tradition of order~\n2  1497 picture: (top) indian encampment, fur trade era picture: (right) john c~"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-4-create-a-table-of-year-and-relevant-history",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-4-create-a-table-of-year-and-relevant-history",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Step 4: Create a table of year and relevant history:",
    "text": "Step 4: Create a table of year and relevant history:\nFinally, I used the reactable package to create an interactive table that contained year as a group. Clicking on a year group reveals history in one or more sentences from Discover Canada:\n\nsuppressPackageStartupMessages(library(reactable))\n\nreactable(\n  dc_df_year,\n  groupBy = \"year\",\n  searchable = TRUE,\n  filterable = TRUE,\n  resizable = TRUE,\n  onClick = \"expand\",\n  showPageSizeOptions = TRUE,\n  columns = list(\n    year = colDef(name = \"Year\", maxWidth = 250),\n    sentence = colDef( name = \"What happened?\")\n   ),\n  theme = reactableTheme(backgroundColor = \"#eadbcb\")\n)\n\n\n\n\n\n\nI am now ready to delve into the Discover Canada study guide further. Ideally, I want to extract the most useful phrases from each sentence for a given year, but at this point I do not know the best way to do that programmatically. If you have any ideas, please share with me on twitter."
  },
  {
    "objectID": "projects/distracted-driving.html",
    "href": "projects/distracted-driving.html",
    "title": "Distracted Driving",
    "section": "",
    "text": "Assisted in the development of driving simulator scenarios to evaluate driver distraction\n\nDeveloped and deployed a dashboard application that worked with real-time driving simulator data to evaluate driver distraction due to music and navigation tasks\n\nCreated computer programs to extract and analyze driving data and participant heart rate data"
  },
  {
    "objectID": "projects/rss.html",
    "href": "projects/rss.html",
    "title": "Machine Learning to Classify Drivers",
    "section": "",
    "text": "Developed clusters of drivers with similar behaviours based on self-reported, psychophysiological, and performance metrics within a simulated environment\n\nApplied machine learning models to predict moderate and conservative drivers"
  },
  {
    "objectID": "projects/vsl.html",
    "href": "projects/vsl.html",
    "title": "Variable Speed Limit System in Ontario, Canada",
    "section": "",
    "text": "Assisted in the development of a new criteria to propose various sites for the deployment of the Variable Speed Limit System in Ontario\nAnalyzed the weather patterns in Ontario to identify the locations with the most severe weather conditions\nDeveloped an interactive map application for the visualization of precipitation and proposed sites for the Variable Speed Limit System in Ontario"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "No matching items"
  },
  {
    "objectID": "software.html",
    "href": "software.html",
    "title": "Software",
    "section": "",
    "text": "R package for running car-following models.\n Code  Website"
  },
  {
    "objectID": "software.html#opendatawindsor",
    "href": "software.html#opendatawindsor",
    "title": "Software",
    "section": "opendatawindsor",
    "text": "opendatawindsor\nR package for downloading data from City of Windsor Open Data Portal.\n Code"
  },
  {
    "objectID": "teaching.html#data-analytics-instructor-at-st.-clair-college",
    "href": "teaching.html#data-analytics-instructor-at-st.-clair-college",
    "title": "Teaching",
    "section": "Data Analytics Instructor at St. Clair College",
    "text": "Data Analytics Instructor at St. Clair College\n\n\n\n\n \n  \n    Semester \n    Course(s) \n  \n \n\n  \n    Spring 2022 \n    Capstone Project \n  \n  \n    Winter 2022 \n    Machine Learning I,\nCapstone Project \n  \n  \n    Fall 2021 \n    Intro. to Artificial Intelligence,    Machine Learning I \n  \n  \n    Spring 2021 \n    Machine Learning I,    Basic Statistics and Exploratory Data Analysis \n  \n  \n    Winter 2021 \n    Analytic Tools and Decision Making,    Basic Statistics and Exploratory Data Analysis \n  \n  \n    Fall 2020 \n    Analytic Tools and Decision Making,   Ethics for Analytics \n  \n  \n    Spring 2020 \n    IT Service Management \n  \n  \n    Fall 2019 \n    Analytic Tools and Decision Making \n  \n  \n    Spring 2019 \n    IT Service Management \n  \n\n\n\n\n\n\nCapstone Projects (Spring 2022)"
  },
  {
    "objectID": "teaching.html#graduate-assistant-at-university-of-windsor",
    "href": "teaching.html#graduate-assistant-at-university-of-windsor",
    "title": "Teaching",
    "section": "Graduate Assistant at University of Windsor",
    "text": "Graduate Assistant at University of Windsor\n\n\n\n\n \n  \n    Semester \n    Course \n    Instructor \n  \n \n\n  \n    Winter 2018 \n    Technical Communications \n    Dr. Jacqueline Stagner \n  \n  \n    Spring 2017 \n    Highway Design and Construction \n    Dr. Chris Lee \n  \n  \n    Winter 2017 \n    Treatment of Experimental Data \n    Dr. Lindsay Miller \n  \n  \n    Fall 2016 \n    Engineering Software Fundamentals \n    Dr. Edward Lang \n  \n  \n    Spring 2016 \n    Transportation and Traffic Engineering \n    Dr. Chris Lee \n  \n  \n    Winter 2016 \n    Numerical Analysis for Engineering \n    Dr. Edward Lang \n  \n  \n    Fall 2015 \n    Engineering Software Fundamentals \n    Dr. Edward Lang \n  \n  \n    Spring 2015 \n    Highway Design and Construction \n    Dr. Chris Lee \n  \n  \n    Fall 2014 \n    Engineering Profession \n    Dr. Leo Oriet \n  \n  \n    Spring 2014 \n    Transportation Systems Analysis \n    Dr. Hanna Maoh \n  \n  \n    Spring 2014 \n    Highway Design and Construction \n    Dr. Chris Lee \n  \n  \n    Winter 2014 \n    Civil Engineering Information System \n    Dr. Hanna Maoh \n  \n  \n    Fall 2013 \n    Engineering Mechanics I \n    Dr. Amr El Ragaby \n  \n\n\n\n\n\n\nInteractive Course: R for Driving Simulator Data"
  },
  {
    "objectID": "teaching.html#lecturerlab-engineer-at-university-of-engineering-technology-lahore-2010---2012",
    "href": "teaching.html#lecturerlab-engineer-at-university-of-engineering-technology-lahore-2010---2012",
    "title": "Teaching",
    "section": "Lecturer/Lab Engineer at University of Engineering & Technology, Lahore (2010 - 2012)",
    "text": "Lecturer/Lab Engineer at University of Engineering & Technology, Lahore (2010 - 2012)\nSubjects taught:\n\nRailway Engineering\n\nConstruction Management\n\nConstruction Materials and Machinery"
  },
  {
    "objectID": "teaching.html#guest-lectures",
    "href": "teaching.html#guest-lectures",
    "title": "Teaching",
    "section": "Guest Lectures",
    "text": "Guest Lectures\n\n“Reaction Time in Car-following” Lecture for Institute of Highway Engineers, UK."
  }
]