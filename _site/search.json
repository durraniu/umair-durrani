[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Welcome to my website"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "How do drivers perceive slow traffic on highways?\n\n\n\n\n\nWiedemann model - a short story\n\n\n\n\n\n\nMay 6, 2023\n\n\n\n\n\n\n  \n\n\n\n\nGipps Model in R, Rcpp, and Julia\n\n\n\n\n\nRace against time\n\n\n\n\n\n\nAug 15, 2022\n\n\n\n\n\n\n  \n\n\n\n\nMaking a History Table of Discover Canada in R\n\n\n\n\n\nManipulating text with {quanteda} and creating a table with {reactable}\n\n\n\n\n\n\nFeb 7, 2021\n\n\n\n\n\n\n  \n\n\n\n\nAutocomplete Character/Factor values in RStudio\n\n\n\n\n\n\n\n\n\n\n\n\nJan 1, 2021\n\n\n\n\n\n\n  \n\n\n\n\nElevation Maps in R\n\n\n\n\n\nLearn to create 3D and Ridgeline plots with an animation bonus.\n\n\n\n\n\n\nDec 25, 2020\n\n\n\n\n\n\n  \n\n\n\n\nDynamic Time Warping and Hierarchical Clustering with {gapminder}\n\n\n\n\n\n\n\n\n\n\n\n\nDec 16, 2020\n\n\n\n\n\n\n  \n\n\n\n\nHow to fit different models on a dataset (the power of purrr)?\n\n\n\n\n\n\n\n\n\n\n\n\nSep 14, 2020\n\n\n\n\n\n\n  \n\n\n\n\nCreating and combining multiple animations with gganimate and magick\n\n\n\n\n\n\n\n\n\n\n\n\nSep 13, 2020\n\n\n\n\n\n\n  \n\n\n\n\nDraw cars with ggplot2\n\n\n\n\n\n\n\n\n\n\n\n\nSep 7, 2020\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hello there, I am Umair Durrani",
    "section": "",
    "text": "Hello there, I am Umair Durrani\nI am a transportation data scientist and traffic modeler. I study and develop models of road users for traffic flow modeling. I am also an instructor of Data Analytics at St. Clair College, Windsor, Ontario. I teach Statistics and data analytics using Python, R, Tableau, Excel, etc. I also supervise capstone projects of students from diverse backgrounds.\nI speak English, Urdu and R (programming) fluently. You can get in touch with me via email or twitter.\n\n\n\n\n\nInterests\n\nHuman Factors in Autonomous Vehicles\nDriver Behaviour & Driver State Monitoring Systems\nMachine Learning Applications in Transportation\nIntelligent Transportation Systems\n\n\n\n\n\n\nEducation\n\n\nPh.D. Civil Engineering \n\nUniversity of Windsor, Ontario, Canada\n\nB.Sc. Transportation Engineering \n\nUniversity of Engineering and Technology, Lahore, Pakistan"
  },
  {
    "objectID": "MLinTransportation/2023-04-15-classifying-traffic-signs/trafficsignsRF.html",
    "href": "MLinTransportation/2023-04-15-classifying-traffic-signs/trafficsignsRF.html",
    "title": "Classifying Traffic Signs with Machine Learning (Part 1)",
    "section": "",
    "text": "This post is part 1 of the three-part series on classifying traffic signs with machine learning. In this part, I will show you how to preprocess images of traffic signs, reshape those images and use them with random forest algorithm for classification. Part of image pre-processing and visualization code comes from The Complete Self Driving Car Course github repo which has a MIT license 1.\nRandom Forest (RF) is generally believed to be a useful algorithm for regression and classification problems where training data is tabular. In this post though, I will be using RF to predict the class of traffic signs that are available as images. Therefore, I would first reshape the input images to tabular form as a large 2-dimensional array (matrix). In the later posts, I will use convolution filters for a neural network as well as RF again to make predictions.\nLet’s begin by loading the required packages."
  },
  {
    "objectID": "MLinTransportation/2023-04-15-classifying-traffic-signs/trafficsignsRF.html#footnotes",
    "href": "MLinTransportation/2023-04-15-classifying-traffic-signs/trafficsignsRF.html#footnotes",
    "title": "Classifying Traffic Signs with Machine Learning (Part 1)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nMIT License\nCopyright (c) 2019 Packt\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.↩︎"
  },
  {
    "objectID": "MLinTransportation/clustering-drivers/clustering-drivers.html",
    "href": "MLinTransportation/clustering-drivers/clustering-drivers.html",
    "title": "Clustering drivers",
    "section": "",
    "text": "Speed-related and large truck collisions are the top two situations with highest road fatalities in Ontario (Ministry of Transportation Ontario 2020). Many studies have found differences in driving styles - such as following a truck too closely - that may help understand the reasons for collisions (Ossen and Hoogendoorn 2011; Durrani, Lee, and Maoh 2016).\nA first step to identify different driving styles is to group together those drivers who have a ‘similar’ driving style. Then the aggregated measures of drivers’ socio-demographic characteristics and driving history may help label a certain style of a group. But how do you define similarity?"
  },
  {
    "objectID": "MLinTransportation/clustering-drivers/clustering-drivers.html#introduction",
    "href": "MLinTransportation/clustering-drivers/clustering-drivers.html#introduction",
    "title": "Clustering drivers",
    "section": "",
    "text": "Speed-related and large truck collisions are the top two situations with highest road fatalities in Ontario (Ministry of Transportation Ontario 2020). Many studies have found differences in driving styles - such as following a truck too closely - that may help understand the reasons for collisions (Ossen and Hoogendoorn 2011; Durrani, Lee, and Maoh 2016).\nA first step to identify different driving styles is to group together those drivers who have a ‘similar’ driving style. Then the aggregated measures of drivers’ socio-demographic characteristics and driving history may help label a certain style of a group. But how do you define similarity?"
  },
  {
    "objectID": "MLinTransportation/clustering-drivers/clustering-drivers.html#determining-similarity",
    "href": "MLinTransportation/clustering-drivers/clustering-drivers.html#determining-similarity",
    "title": "Clustering drivers",
    "section": "Determining Similarity",
    "text": "Determining Similarity\nDefining similarity is a challenge because each driver has multiple data points e.g., speed that varies over time. For example, the following shows the speed profiles (also called as trajectories) of three drivers in lane 1 on Interstate-80 (I-80) in United States (based on the cleaned I80 data from Montanino and Punzo 2015):\n\nsuppressPackageStartupMessages(library(tidyverse))\n\ndf_2_drivers &lt;- df %&gt;% \n  filter(Lane == 1,\n         Vehicle.ID %in% c(204, 206, 218))\n\nggplot(data = df_2_drivers,\n       aes(group = Vehicle.ID, x = Time, y = svel)) +\n  geom_path(aes(color = as.character(Vehicle.ID))) +\n  labs(x = \"Time (s)\", y = \"Speed (m/s)\",\n       color = \"Vehicle ID\") \n\n\n\n\nSo, which of the two trajectories above are the most similar? Qualitatively, we may say that speed trajectories of vehicles 204 and 206 seem to be be alike in magnitude and pattern, while vehicle 218 is different. But how do we quantify the similarity?\n\nDynamic Time Warping\nWe may estimate the difference between speeds of 2 vehicles at each point in time and sum up all the differences to get an overall similarity measure. But this won’t work when the time-series of speed are unequal in length. This approach also ignores the similar pattern (e.g., increase in speed) after a time lag. Dynamic Time Warping (DTW) algorithm can account for this similarity with/without a time lag, and also compares each value with every other value between the two time-series. Therefore, a DTW score is a measure of dissimilarity between two time-series. The higher the score, more is the dissimilarity. You can learn the basics of DTW with this tutorial.\nThe following code shows how to determine the DTW score between the speeds of the vehicles 204 and 206:\n\nsuppressPackageStartupMessages(library(dtw))\n\n\ndataa &lt;- df_2_drivers %&gt;% \n  filter(Vehicle.ID==204) %&gt;% \n  pull(svel)\n\n\nquery &lt;- df_2_drivers %&gt;% \n  filter(Vehicle.ID==206) %&gt;% \n  pull(svel)\n\n\n\nalignment &lt;- dtw(query, dataa, keep=TRUE)\n\n\nplot(alignment, type=\"twoway\")\n\n\n\npaste0(\"DTW score between vehicles 204 and 206: \", alignment$distance)\n\n[1] \"DTW score between vehicles 204 and 206: 155.26969\"\n\n\nSimilarly, the DTW score between vehicles 204 and 218 is 240.33987. Since this score is higher than the previous one, it confirms our visual inference that vehicles 204 and 206 have more similar speeds than vehicles 204 and 218."
  },
  {
    "objectID": "MLinTransportation/clustering-drivers/clustering-drivers.html#clustering-drivers-using-dtw-score-as-a-distance-measure",
    "href": "MLinTransportation/clustering-drivers/clustering-drivers.html#clustering-drivers-using-dtw-score-as-a-distance-measure",
    "title": "Clustering drivers",
    "section": "Clustering Drivers using DTW score as a distance measure",
    "text": "Clustering Drivers using DTW score as a distance measure\nSo far we have seen how to compare pairs of vehicles using DTW score as a dissimilarity measure. We now want to use DTW score to compare all pairs of vehicles. Not only that, we want to use multiple variables, i.e., speed, speed-difference and spacing between two vehicles, etc. Since all of these variables change over time, they are considered as multivariate time-series.\nClustering algorithms, such as Hierarchical Clustering, can group together those vehicles/drivers that have small dissimilarities i.e., DTW score. The dtwclust package in R (Sarda-Espinosa 2019) automates the calculation of the DTW score and clustering them.\n\nData\nWe are going to use data from 500 randomly sampled vehicles on lanes 1, 2, and 3 from the I-80 vehicle trajectories database. These vehicles were observed for at least 30 seconds. The selected data below contains the speed, speed-difference and spacing only.\n\nset.seed(123)\nsampled_vehs &lt;- df %&gt;% \n  pull(Vehicle.ID) %&gt;% \n  unique() %&gt;% \n  sample(., 500)\n\ndf_sampled &lt;- df %&gt;% \n  filter(Vehicle.ID %in% sampled_vehs) %&gt;% \n  select(Vehicle.ID, Time, svel, frspacing, dV)\n\ndf_sampled %&gt;% head()\n\n# A tibble: 6 x 5\n  Vehicle.ID  Time  svel frspacing       dV\n       &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1         11   0    4.42      11.6 -0.00292\n2         11   0.1  4.42      11.6 -0.00103\n3         11   0.2  4.42      11.6  0.00108\n4         11   0.3  4.43      11.6  0.00458\n5         11   0.4  4.43      11.6  0.0106 \n6         11   0.5  4.44      11.6  0.0210 \n\n\nThe structure of the data above is called as a dataframe in R. Unfortunately, dtwclust does not accept a dataframe. Therefore, we are reshaping the data in a list format that would contain a matrix for each vehicle. Following shows what it looks like for vehicles 11 and 24:\n\ndf_matrix &lt;- df_sampled %&gt;% \n  split(.$Vehicle.ID, drop = T) %&gt;% \n  purrr::map(~ .x[, c(\"svel\", \"frspacing\", \"dV\"\n  )]) %&gt;% \n  purrr::map(as.matrix) \n\n\nstr(df_matrix, list.len=2)\n\nList of 500\n $ 11  : num [1:646, 1:3] 4.42 4.42 4.42 4.43 4.43 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:3] \"svel\" \"frspacing\" \"dV\"\n $ 24  : num [1:613, 1:3] 4 3.78 4 4.2 4.35 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:3] \"svel\" \"frspacing\" \"dV\"\n  [list output truncated]"
  },
  {
    "objectID": "MLinTransportation/clustering-drivers/clustering-drivers.html#clustering",
    "href": "MLinTransportation/clustering-drivers/clustering-drivers.html#clustering",
    "title": "Clustering drivers",
    "section": "Clustering",
    "text": "Clustering\nNow we use the tsclust function from the dtwclust package to cluster the vehicles using hierarchical clustering with DTW score as a distance measure. We assume here that the number of clusters, k are 2. Moreover, we normalize the data using zscore:\n\nsuppressPackageStartupMessages(library(dtwclust))\n\nclusters_gp &lt;- df_matrix %&gt;% \n  tsclust(., \n          k = 2L,                 # assuming clusters\n          distance = \"dtw_basic\", # this is dtw score\n          seed = 390,             # to reproduce results\n          type=\"hierarchical\",    # type of clustering\n          control = hierarchical_control(method = \"ward.D\"),\n          preproc = zscore) # method in hc\n\nclusters_gp\n\nhierarchical clustering with 2 clusters\nUsing dtw_basic distance\nUsing PAM (Hierarchical) centroids\nUsing method ward.D \nUsing zscore preprocessing\n\nTime required for analysis:\n   user  system elapsed \n 456.99    0.53  123.39 \n\nCluster sizes with average intra-cluster distance:\n\n  size  av_dist\n1  256 1154.451\n2  244 1299.892\n\n\nThe vehicles are now clustered and have cluster numbers. To visualize them, we need to include these numbers in the dataframe df_sampled:\n\nGps &lt;- as.data.frame(cutree(clusters_gp, k = 2)) # num of clusters\ncolnames(Gps) &lt;- \"Gp\"\nGps$Vehicle.ID &lt;- row.names(Gps)\nrow.names(Gps) &lt;- NULL\nGps$Vehicle.ID &lt;- as.integer(Gps$Vehicle.ID)\n\n\n## Getting the clustering info into the original data\ndf_clustered &lt;- df_sampled %&gt;% \n  filter(Vehicle.ID %in% sampled_vehs) %&gt;% \n  left_join(x=., y=Gps, by = \"Vehicle.ID\")\n\ndf_clustered %&gt;% head(3)\n\n# A tibble: 3 x 6\n  Vehicle.ID  Time  svel frspacing       dV    Gp\n       &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;int&gt;\n1         11   0    4.42      11.6 -0.00292     1\n2         11   0.1  4.42      11.6 -0.00103     1\n3         11   0.2  4.42      11.6  0.00108     1\n\n\nPlots of each variable are shown below. The numbers at the top represent the cluster numbers:\n\n# speed\nggplot(data = df_clustered,\n       aes(x = Time, y = svel)) +\n  geom_line(aes(group=Vehicle.ID), color = \"grey\") +\n  geom_smooth(method=\"lm\") +\n  facet_wrap(~ Gp) +\n  labs(x = \"Time (s)\", y = \"Speed (m/s)\", title = \"Speed\")\n\n\n\n# spacing\nggplot(data = df_clustered,\n       aes(x = Time, y = frspacing)) +\n  geom_line(aes(group=Vehicle.ID), color = \"grey\") +\n  geom_smooth(method=\"lm\") +\n  facet_wrap(~ Gp) +\n  labs(x = \"Time (s)\", y = \"Front-to-rear Spacing (m)\", title = \"Spacing\")\n\n\n\n\nAn interesting finding in these plots is that drivers in cluster 1 increased their speeds while drivers in cluster 2 decreased their speeds over time. This clustering exercise raises an interesting exploratory question: Why drivers in cluster 1 had higher spacing and speed towards the end of observation? But we won’t dig into that in this post. You can now see the utility of DTW as an exploratory tool in investigating driver behaviour. Try it on your own data!"
  },
  {
    "objectID": "MLinTransportation/clustering-drivers/clustering-drivers.html#another-example",
    "href": "MLinTransportation/clustering-drivers/clustering-drivers.html#another-example",
    "title": "Clustering drivers",
    "section": "Another Example",
    "text": "Another Example\nI leave you with one more application of DTW that was a joint work to cluster drivers based on their kinematics data, as well as other interesting variables. See the presentation and paper below from the proceedings of Road Safety and Simulation Conference.\nPlease ask any questions or leave comments below.\n\nPresentationPaper"
  },
  {
    "objectID": "MLinTransportation.html",
    "href": "MLinTransportation.html",
    "title": "Machine Learning Applications in Transportation",
    "section": "",
    "text": "Classifying Traffic Signs with Machine Learning (Part 1)\n\n\n\n\n\nRandom Forest begins\n\n\n\n\n\n\nApr 16, 2023\n\n\n\n\n\n\n  \n\n\n\n\nClustering drivers\n\n\n\n\n\nUsing Dynamic Time Warping (DTW) algorithm to cluster drivers\n\n\n\n\n\n\nAug 13, 2022\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html",
    "href": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html",
    "title": "Draw cars with ggplot2",
    "section": "",
    "text": "Thanks to BrodieG for answering my stackoverflow question about drawing diagrams in R."
  },
  {
    "objectID": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#credit",
    "href": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#credit",
    "title": "Draw cars with ggplot2",
    "section": "",
    "text": "Thanks to BrodieG for answering my stackoverflow question about drawing diagrams in R."
  },
  {
    "objectID": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#creating-geom_car",
    "href": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#creating-geom_car",
    "title": "Draw cars with ggplot2",
    "section": "Creating geom_car",
    "text": "Creating geom_car\nCreating a new geom in ggplot2 is much more complicated then using the ggplot2 interface. The official gpplot2 book, ggplot2: Elegant Graphics for Data Analysis, says the following:\n\nWhen making the jump from user to developer, it is common to encounter frustrations because the nature of the ggplot2 interface is very different to the structure of the underlying machinery that makes it work\n\nAnd I completely agree. The chapter that the above quote is from explains that ggplot2 uses the ggproto class system to create new objects such as geoms.\nThe following shows the use of ggproto that creates the geom_car. Again, the code is not mine but provided by Brodie G (thanks!).\nFirst, load libraries.\n\nLoad Libraries\n\nsuppressPackageStartupMessages( library(tidyverse) )\n\nWarning: package 'tidyverse' was built under R version 4.0.5\n\n\nWarning: package 'tidyr' was built under R version 4.0.5\n\nsuppressPackageStartupMessages( library(here) )\nsuppressPackageStartupMessages( library(readr) )\n\n\n\nLoad data\nI am using a dataset of 2 cars. The Following car is approaching a Lead car from a large distance. The Lead car is stopped. The dataset contains the x and y coordinates of the centroid of cars and their sizes.\n\ndf &lt;- read_csv(\"driver_data.csv\")\n\n\n-- Column specification --------------------------------------------------------\ncols(\n  Time_s = col_double(),\n  ED_x_m = col_double(),\n  ED_y_m = col_double(),\n  LV_x_m = col_double(),\n  LV_y_m = col_double(),\n  LV_length_m = col_double(),\n  LV_width_m = col_double(),\n  visual_angle_W = col_double(),\n  visual_angle_H = col_double(),\n  tau = col_double(),\n  ED_length_m = col_double(),\n  ED_width_m = col_double()\n)\n\nhead(df)\n\n# A tibble: 6 x 12\n  Time_s ED_x_m ED_y_m LV_x_m LV_y_m LV_length_m LV_widt~1 visua~2 visua~3   tau\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1      1  4341. -8921.  3991. -7732.        5.39      2.29 0.00185 0.00128  55.1\n2      2  4335. -8899.  3991. -7732.        5.39      2.29 0.00189 0.00130  52.8\n3      3  4329. -8877.  3991. -7732.        5.39      2.29 0.00193 0.00133  50.7\n4      4  4322. -8854.  3991. -7732.        5.39      2.29 0.00197 0.00136  48.6\n5      5  4315. -8831.  3991. -7732.        5.39      2.29 0.00201 0.00138  46.9\n6      6  4308. -8808.  3991. -7732.        5.39      2.29 0.00205 0.00141  45.3\n# ... with 2 more variables: ED_length_m &lt;dbl&gt;, ED_width_m &lt;dbl&gt;, and\n#   abbreviated variable names 1: LV_width_m, 2: visual_angle_W,\n#   3: visual_angle_H\n# i Use `colnames()` to see all variable names\n\n\n\n\nCoordinates plot\nFollowing plot shows that in the original data format, the Following car moves up and left towards the lead car.\n\nggplot(data = df,\n       aes(x = ED_x_m, y = ED_y_m)) +\n  geom_line(aes(color = \"Following car\"))\n\n\n\n\n\n\nStep 1: Create a car image with no fill color\nThe stackoverflow answer comes with a car image, but I wanted to experiment with my own image. So, I created one with no fill color. This was important to enable the fill method in geom_car. Then it was read by the png::readPNG method:\n\ncar.raster &lt;- png::readPNG(\"car4.png\")\n\nstr(car.raster)\n\n num [1:238, 1:505, 1:4] 0 0.184 0.184 0.184 0.184 ...\n\n\n\n\nStep 2: Create a graphical object (grob) from the image\n\n# Generate a car 'grob' using a baseline PNG\n\n# The `grid` grob actually responsible for rendering our car, \n# combines our transparent car elements with a background rectangle\n# for color/fill.\n\ncarGrob &lt;- function(x, y, length, width, gp) {\n  grid::grobTree(\n    grid::rectGrob(\n      x, y, hjust=.5, height=width, width=length,\n      gp = gp\n    ),\n    grid::rasterGrob(\n      car.raster, x=x, y=y, hjust=.5, height=width, width=length\n    ) ) }\n\n\n\nStep 3: Map the data to the grob using ggproto\n\n# The `ggproto` object that maps our data to the `grid` grobs\n\nGeomCar &lt;- ggplot2::ggproto(\"GeomCar\", ggplot2::Geom,\n                            # Generate grobs from the data, we have to reconvert length/width so\n                            # that the transformations persist\n                            \n                            draw_panel=function(self, data, panel_params, coords) {\n                              with(\n                                coords$transform(data, panel_params),\n                                carGrob(\n                                  x, y, length=xmax-xmin, width=ymax-ymin,\n                                  gp=grid::gpar(\n                                    col = colour, fill = alpha(fill, alpha),\n                                    lwd = size * .pt, lty = linetype, lineend = \"butt\"\n                                  ) ) ) },\n                            # Convert data to coordinates that will get transformed (length/width don't\n                            # normally).\n                            \n                            setup_data=function(self, data, params) {\n                              transform(data,\n                                        xmin = x - length / 2, xmax = x + length / 2,\n                                        ymin = y - width / 2, ymax = y + width / 2\n                              ) },\n                            # Required and default aesthetics\n                            \n                            required_aes=c(\"x\", \"y\", \"length\", \"width\"),\n                            default_aes = aes(\n                              colour = NA, fill = \"grey35\", size = 0.5, linetype = 1, alpha = NA\n                            ),\n                            # Use the car grob in the legend\n                            \n                            draw_key = function(data, params, size) {\n                              with(\n                                data,\n                                carGrob(\n                                  0.5, 0.5, length=.75, width=.5,\n                                  gp = grid::gpar(\n                                    col = colour, fill = alpha(fill, alpha),\n                                    lwd = size * .pt, lty = linetype, lineend = \"butt\"\n                                  ) ) ) }\n)\n\n\n\nStep 4: Create the external interface i.e. the geom_car layer\n\n# External interface\n\ngeom_car &lt;- function(\n  mapping=NULL, data=NULL, ..., inherit.aes=TRUE, show.legend=NA\n) {\n  layer(\n    data=data, mapping=mapping, geom=GeomCar, position=\"identity\",\n    stat=\"identity\", show.legend = show.legend, inherit.aes = inherit.aes,\n    params=list(...)\n  )\n}"
  },
  {
    "objectID": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#plotting-the-cars",
    "href": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#plotting-the-cars",
    "title": "Draw cars with ggplot2",
    "section": "Plotting the cars",
    "text": "Plotting the cars\nI can now use geom_car to plot the cars. Since the coordinates change every second (see the Time_s column above), I need to filter for one time only. So, I choose Time_s == 49.\n\nAttempt 1 to plot cars\n\nggplot(df %&gt;% filter(Time_s == 49) ) +\n  geom_car(aes(x=ED_x_m, y=ED_y_m, \n               length=ED_length_m, width=ED_width_m, \n               fill=\"ed\")) +\n  geom_text(aes(x=ED_x_m, y=ED_y_m+5), \n            label = \"Following Car\") +\n  \n  geom_car(aes(x=LV_x_m, y=LV_y_m, \n               length=LV_length_m, width=LV_width_m, \n               fill=\"lv\")) +\n  geom_text(aes(x=LV_x_m, y=LV_y_m+5), \n            label = \"Lead Car\\n(stationary)\") +\n\n  coord_equal(ratio = 0.7) +\n  theme(legend.position = \"none\")\n\n\n\n\nThis does not look right. The Following car seems to be ahead of the lead car. Also, due to the elongated scale, the Following car appears to be in a different lane. The main reason is the unusual coordinates. The x coordinates decrease as the Following car gets closer to the lead car.\nI can fix this by scaling: subtracting the x coordinates from the largest x coordinate in the data.\n\n\nAttemp 2: Adjust the coordinates and plot again\n\nAdjust coordinates:\n\nfirst_ed_x_coord &lt;- df %&gt;% pull(ED_x_m) %&gt;% range() %&gt;% tail(1)\n\ndf &lt;- df %&gt;% \n  mutate(\n    ED_x_m_a = abs(ED_x_m - first_ed_x_coord),\n    LV_x_m_a = abs(LV_x_m - first_ed_x_coord)\n         )\n\n\n\nPlot:\n\nggplot(df %&gt;% filter(Time_s == 49) ) +\n  geom_car(aes(x=ED_x_m_a, y=ED_y_m, \n               length=ED_length_m, width=ED_width_m, \n               fill=\"ed\")) +\n  geom_text(aes(x=ED_x_m_a, y=ED_y_m+5), \n            label = \"Following Car\") +\n  \n  geom_car(aes(x=LV_x_m_a, y=LV_y_m, \n               length=LV_length_m, width=LV_width_m, \n               fill=\"lv\")) +\n  geom_text(aes(x=LV_x_m_a, y=LV_y_m+5), \n            label = \"Lead Car\\n(stationary)\") +\n\n  coord_equal(ratio = 0.7) +\n  theme(legend.position = \"none\")\n\n\n\n\nThis is better. Now, to fix the problem of the elongated y coordinate, I can fix them to a single value, because I’m mainly interested in the movement along the x-axis. But note that this might not be a good idea if there is a large change in y coordinate (e.g. in a lane change).\n\n\n\nAttempt 3 - Fixing y coordinate\n\ncar_plot &lt;- ggplot(df %&gt;% filter(Time_s == 49) ) +\n  geom_car(aes(x=ED_x_m_a, y=300, \n               length=ED_length_m, width=ED_width_m, \n               fill=\"ed\")) +\n  geom_text(aes(x=ED_x_m_a, y=300+5), \n            label = \"Following Car\") +\n  \n  geom_car(aes(x=LV_x_m_a, y=300, \n               length=LV_length_m, width=LV_width_m, \n               fill=\"lv\")) +\n  geom_text(aes(x=LV_x_m_a, y=300+5), \n            label = \"Lead Car\\n(stationary)\") +\n  theme_void() +\n  coord_equal(ratio = 1) +\n  theme(legend.position = \"none\",\n        axis.text = element_blank(),\n        axis.title = element_blank(),\n        axis.ticks = element_blank())\n\ncar_plot\n\n\n\n\nThis looks much better. :D"
  },
  {
    "objectID": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#car-rear-view",
    "href": "posts/2020-09-07-creating-your-own-geom-in-ggplot2/2020-09-07-creating-your-own-geom-in-ggplot2.html#car-rear-view",
    "title": "Draw cars with ggplot2",
    "section": "Car Rear View",
    "text": "Car Rear View\nI also created a geom_car_rear by using a different image (car rear created in powerpoint). Following plots the car rear at time = 49 s.\n\nggplot(df %&gt;% filter(Time_s == 49)) +\n  geom_car_rear(aes(x=0, y=0, length=visual_angle_W,\n               width=visual_angle_H), fill=\"black\") +\n  theme_void()"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "",
    "text": "Thanks to Robert Walker for showing how to combine multiple animations using the magick package in R.\n\n\nWow, you can side-by-side gganimates with imagemagick. That was fun to put together. #rstats #tidyTuesday An adaptation of measles and a map… pic.twitter.com/FPOgAOQS84\n\n— Robert Walker (@PieRatio) December 16, 2019"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#credit",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#credit",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "",
    "text": "Thanks to Robert Walker for showing how to combine multiple animations using the magick package in R.\n\n\nWow, you can side-by-side gganimates with imagemagick. That was fun to put together. #rstats #tidyTuesday An adaptation of measles and a map… pic.twitter.com/FPOgAOQS84\n\n— Robert Walker (@PieRatio) December 16, 2019"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#load-data",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#load-data",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Load data",
    "text": "Load data\nI am using a dataset that contains car positions, speed and distance (also called as spacing).\n\nsuppressPackageStartupMessages( library(tidyverse) )\nsuppressPackageStartupMessages( library(magick) )\nsuppressPackageStartupMessages( library(gganimate) )\nsuppressPackageStartupMessages( library(here) )\nsuppressPackageStartupMessages( library(readr) )\n\ndf &lt;- read_csv(\"vb.csv\")\n\n\n-- Column specification --------------------------------------------------------\ncols(\n  Time_s = col_double(),\n  ED_x_m = col_double(),\n  LV_x_m = col_double(),\n  LV_length_m = col_double(),\n  LV_width_m = col_double(),\n  visual_angle_W = col_double(),\n  visual_angle_H = col_double(),\n  tau = col_double(),\n  ED_speed_mps = col_double(),\n  LV_speed_mps = col_double(),\n  LV_frspacing_m = col_double(),\n  ED_gas_pedal_pos = col_double(),\n  ED_brake_pedal_force_kg = col_double(),\n  tau_inv = col_double()\n)\n\ndf\n\n# A tibble: 49 x 14\n   Time_s ED_x_m LV_x_m LV_lengt~1 LV_wi~2 visua~3 visua~4   tau ED_sp~5 LV_sp~6\n    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1      1  4341.  3991.       5.39    2.29 0.00185 0.00128  55.1    22.4       0\n 2      2  4335.  3991.       5.39    2.29 0.00189 0.00130  52.8    22.9       0\n 3      3  4329.  3991.       5.39    2.29 0.00193 0.00133  50.7    23.5       0\n 4      4  4322.  3991.       5.39    2.29 0.00197 0.00136  48.6    24.0       0\n 5      5  4315.  3991.       5.39    2.29 0.00201 0.00138  46.9    24.3       0\n 6      6  4308.  3991.       5.39    2.29 0.00205 0.00141  45.3    24.7       0\n 7      7  4302.  3991.       5.39    2.29 0.00210 0.00145  43.7    25         0\n 8      8  4294.  3991.       5.39    2.29 0.00215 0.00148  42.1    25.3       0\n 9      9  4287.  3991.       5.39    2.29 0.00220 0.00152  40.6    25.7       0\n10     10  4280.  3991.       5.39    2.29 0.00226 0.00156  39.1    26.0       0\n# ... with 39 more rows, 4 more variables: LV_frspacing_m &lt;dbl&gt;,\n#   ED_gas_pedal_pos &lt;dbl&gt;, ED_brake_pedal_force_kg &lt;dbl&gt;, tau_inv &lt;dbl&gt;, and\n#   abbreviated variable names 1: LV_length_m, 2: LV_width_m,\n#   3: visual_angle_W, 4: visual_angle_H, 5: ED_speed_mps, 6: LV_speed_mps\n# i Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names\n\n\nAs discussed in the previous blogpost, I had to adjust the coordinates to make one car appear approaching another car. So, we estimate the first and last coordinates in the data to do that.\n\n# Largest x coordinate of following vehicle------------------\n  first_ed_x_coord &lt;- df %&gt;% pull(ED_x_m) %&gt;% range() %&gt;% tail(1)\n  last_ed_x_coord &lt;- df %&gt;% pull(ED_x_m) %&gt;% range() %&gt;% head(1)"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#top-view",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#top-view",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Top view",
    "text": "Top view\n\n# animation of position---------------------------------------\n  ani_car_b &lt;- ggplot(df) +\n    geom_car(aes(x=abs(ED_x_m-first_ed_x_coord), \n                 y=first_ed_x_coord-last_ed_x_coord, length=4.64, width=2.078, fill=\"ed\")) +\n    geom_text(aes(x=abs(ED_x_m-first_ed_x_coord), y = (first_ed_x_coord-last_ed_x_coord)+3,\n                  label = paste(\"Following Car\\nSpeed =\", ED_speed_mps, \"m/s\")),\n              color=\"darkgray\"\n    ) +\n    geom_car(aes(x=abs(LV_x_m-first_ed_x_coord), y=first_ed_x_coord-last_ed_x_coord, length=LV_length_m,\n                 width=LV_width_m, fill=\"lv\")) +\n    geom_text(aes(x=abs(LV_x_m-first_ed_x_coord), y = (first_ed_x_coord-last_ed_x_coord)+3, \n                  label = paste(\"Lead Car\\nSpeed =\", LV_speed_mps, \"m/s\")),\n              color=\"darkgray\") +\n    \n    geom_segment(aes(x = abs(ED_x_m-first_ed_x_coord)+(0.5*4.64),\n                     xend = abs(LV_x_m-first_ed_x_coord)-(0.5*LV_length_m),\n                     y = first_ed_x_coord-last_ed_x_coord,\n                     yend= first_ed_x_coord-last_ed_x_coord), \n                 arrow = arrow(length = unit(0.1, \"inches\"), ends = \"both\")) +\n    geom_text(aes(x= ((abs(ED_x_m-first_ed_x_coord)+(0.5*4.64))+(abs(LV_x_m-first_ed_x_coord)-(0.5*LV_length_m)))/2, y = (first_ed_x_coord-last_ed_x_coord)+3.5, \n                  label = paste(\"Spacing =\", LV_frspacing_m, \"m\")),\n              color=\"darkgray\") +\n    \n    coord_equal(ratio=0.7) +\n    scale_fill_manual(values = c(\"blue\", \"black\")) +\n    theme_void() +\n    theme(legend.position = \"none\",\n          axis.text = element_blank(),\n          axis.title = element_blank(),\n          axis.ticks = element_blank()\n    ) +\n    transition_manual(Time_s) +\n    ease_aes() +\n    view_follow()\n\nani_car_b\n\nnframes and fps adjusted to match transition"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#pedal-positions-and-inverse-time-to-collision",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#pedal-positions-and-inverse-time-to-collision",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Pedal positions and inverse time-to-collision",
    "text": "Pedal positions and inverse time-to-collision\nThe following animation shows how the gas and brake pedal positions change over time. The variable tau-inverse represents the inverse of time-to-collision (seconds until collision happens if cars don’t change their speeds).\n\n# animation of pedals/looming---------------------------------------\npedals_pos_b &lt;- ggplot(data = df,\n                         mapping = aes(x = Time_s)) +\n    geom_line(aes(y = tau_inv*10), color = \"black\") +\n    geom_text(aes(y = tau_inv*10,\n                  label = paste(\"tau-inv =\", round(tau_inv, 2))), color = \"black\",\n              size = 5) +\n    geom_area(aes(y = tau_inv*10), fill = \"gray\",\n              position = \"identity\", alpha=0.6)+\n    \n    geom_line(aes(y = scale(ED_gas_pedal_pos)), color = \"darkgreen\") +\n    geom_text(aes(y = scale(ED_gas_pedal_pos)),\n              label = \"Gas Pedal\", color = \"darkgreen\") +\n    \n    geom_line(aes(y = scale(ED_brake_pedal_force_kg)), color = \"red\") +\n    geom_text(aes(y = scale(ED_brake_pedal_force_kg)),\n              label = \"Brake Pedal\", color = \"red\") +\n    \n    geom_text(x= 10, y = 4, \n              aes(label = paste(\"Brake Pedal Force =\", \n                                round(ED_brake_pedal_force_kg), \"kg\"))) +\n    theme_void() +\n    transition_reveal(Time_s)\n  \n\n pedals_pos_b"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#drivers-front-view",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#drivers-front-view",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Driver’s front view",
    "text": "Driver’s front view\nThe following animation shows what the driver in the following car sees from the windscreen. It represents how the image of the lead vehicle grows on the following driver’s retina.\n\n# animation of car rear---------------------------------------\nani_retina_b &lt;- ggplot(df ) +\n    geom_car_rear(aes(x=0, y=0, length=visual_angle_W,\n                      width=visual_angle_H), fill=\"black\") +\n    theme_void() +\n    theme(axis.text = element_blank(),\n          axis.title = element_blank(),\n          axis.ticks = element_blank())+\n    coord_fixed(ratio = 0.7) +\n    transition_manual(Time_s) \n  \n ani_retina_b\n\nnframes and fps adjusted to match transition"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#rendering-animations-and-saving-them",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#rendering-animations-and-saving-them",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Rendering animations and saving them",
    "text": "Rendering animations and saving them\nNow that the three animations are created, we can render them using gganimate::animate function. Without doing this, the animations are rendered every time we call them.\n\n# Rendering gifs-------------------------------------------------\n  a_gif &lt;- animate(ani_car_b, height = 3, width = 8, end_pause = 15,\n                   units = \"in\", res = 150, fps = 5, duration=10)\n  b_gif &lt;- animate(pedals_pos_b, fps = 5, duration=10,\n                   height = 3.5, width = 4.5, end_pause = 15,\n                   units = \"in\", res = 150)\n  c_gif &lt;- animate(ani_retina_b, fps = 5, duration=10,\n                   height = 3.5, width = 3.5, end_pause = 15,\n                   units = \"in\", res = 150)\n  \n## saving  \nanim_save(filename = \"a_gif.gif\",\n          animation = a_gif)\nanim_save(filename = \"b_gif.gif\",\n          animation = b_gif)\nanim_save(filename = \"c_gif.gif\",\n          animation = c_gif)"
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#reading-the-gif-images",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#reading-the-gif-images",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Reading the gif images",
    "text": "Reading the gif images\n\n# Convertig the rendered gifs to magick class-------------\n  a_mgif &lt;- image_read(path = \"a_gif.gif\")\n  b_mgif &lt;- image_read(path = \"b_gif.gif\")\n  c_mgif &lt;- image_read(path = \"c_gif.gif\")\n\nBy the reading the saved gif images (animations) using magick::image_read(), we convert the animation from the gif_image class to magick-image class."
  },
  {
    "objectID": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#aligning-the-animations",
    "href": "posts/2020-09-13-combining-multiple-animations/2020-09-13-combining-multiple-animations.html#aligning-the-animations",
    "title": "Creating and combining multiple animations with gganimate and magick",
    "section": "Aligning the animations",
    "text": "Aligning the animations\nFinally, we combine the animations using a for-loop and magick::image_append:\n\n# Aligning gifs-------------------------------------------------\n  bc_gif &lt;- image_append(c(b_mgif[1], c_mgif[1]), stack = FALSE)\n  for(i in 2:50){\n    combined &lt;- image_append(c(b_mgif[i], c_mgif[i]), stack = FALSE)\n    bc_gif &lt;- c(bc_gif, combined)\n  }\n\n  new_gif &lt;- image_append(c(a_mgif[1], bc_gif[1]), stack = TRUE)\n  for(i in 2:50){\n    combined &lt;- image_append(c(a_mgif[i], bc_gif[i]), stack = TRUE)\n    new_gif &lt;- c(new_gif, combined)\n  }\n\n new_gif"
  },
  {
    "objectID": "posts/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package.html",
    "href": "posts/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package.html",
    "title": "How to fit different models on a dataset (the power of purrr)?",
    "section": "",
    "text": "I wanted to fit multiple models on a dataset in R, and I had no idea how to do that efficiently. So, I turned to twitter and got an amazing reply:\n\n\nLike this? pic.twitter.com/uGcKpVGLbH\n\n— Daniel Anderson (@datalorax_) April 24, 2019\n\n\nPurrrfect!! Thank you Daniel.\n\n\nI created a short tutorial to show the steps for fitting a model to multiple datasets or fitting multiple models to a single dataset:"
  },
  {
    "objectID": "posts/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package.html#a-short-screencast",
    "href": "posts/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package/2020-09-14-create-quick-3d-maps-in-r-with-g3r-package.html#a-short-screencast",
    "title": "How to fit different models on a dataset (the power of purrr)?",
    "section": "",
    "text": "I created a short tutorial to show the steps for fitting a model to multiple datasets or fitting multiple models to a single dataset:"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "",
    "text": "I want to find which countries are the most similar to each other in terms of their life expectancy, population and GDP over the years"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-1-choose-the-variables-you-want-to-use-in-calculating-the-dtw-dissimilarity-score",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-1-choose-the-variables-you-want-to-use-in-calculating-the-dtw-dissimilarity-score",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Step 1) Choose the variables you want to use in calculating the dtw dissimilarity score",
    "text": "Step 1) Choose the variables you want to use in calculating the dtw dissimilarity score\nHere, I am choosing to use only the countries in Asia, and I am going to use life expectancy, population and GDP for the estimation of dtw score.\nAlso, it is important to scale all variables as right now they are in different scales. You can also scale them in the function that does the clustering.\n\n### Function to scale a variable\nscale_this &lt;- function(x){\n  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)\n}\n\n\ndf &lt;- gapminder %&gt;% \n  filter(continent == \"Asia\") %&gt;% # countries in Asia only\n  group_by(country) %&gt;%           # scaling the vars for each country\n  mutate(lifeExp = scale_this(lifeExp),\n         pop = scale_this(pop),\n         gdpPercap = scale_this(gdpPercap)\n  ) %&gt;%\n  ungroup()\n\ndf\n\n# A tibble: 396 x 6\n   country     continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952  -1.70  -1.04      -0.215\n 2 Afghanistan Asia       1957  -1.40  -0.925      0.168\n 3 Afghanistan Asia       1962  -1.08  -0.781      0.466\n 4 Afghanistan Asia       1967  -0.678 -0.602      0.310\n 5 Afghanistan Asia       1972  -0.273 -0.386     -0.579\n 6 Afghanistan Asia       1977   0.188 -0.133     -0.153\n 7 Afghanistan Asia       1982   0.466 -0.414      1.62 \n 8 Afghanistan Asia       1987   0.656 -0.275      0.460\n 9 Afghanistan Asia       1992   0.823  0.0695    -1.42 \n10 Afghanistan Asia       1997   0.840  0.900     -1.55 \n# ... with 386 more rows\n# i Use `print(n = ...)` to see more rows"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-2-split-the-data-by-each-country-and-convert-to-a-matrix",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-2-split-the-data-by-each-country-and-convert-to-a-matrix",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Step 2) Split the data by each country and convert to a matrix",
    "text": "Step 2) Split the data by each country and convert to a matrix\nThis is required by the dtwclust package.\n\ndf_matrix &lt;- df %&gt;% \n  split(.$country, drop = T) %&gt;% \n  purrr::map(~ .x[, c(\"lifeExp\",    # names of all vars\n                       \"pop\",\n                       \"gdpPercap\"\n                      )]) %&gt;% \n  purrr::map(as.matrix) \n\n### printing out df shows the matrices by country\nstr(df_matrix[[1]])\n\n num [1:12, 1:3] -1.702 -1.402 -1.075 -0.678 -0.273 ...\n - attr(*, \"dimnames\")=List of 2\n  ..$ : NULL\n  ..$ : chr [1:3] \"lifeExp\" \"pop\" \"gdpPercap\""
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-3-use-the-tsclust-function-from-the-dtwclust-package-for-clustering-using-the-dtw-score",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#step-3-use-the-tsclust-function-from-the-dtwclust-package-for-clustering-using-the-dtw-score",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Step 3) Use the tsclust function from the dtwclust package for clustering using the dtw score",
    "text": "Step 3) Use the tsclust function from the dtwclust package for clustering using the dtw score\nBoth steps are done using a single function:\n\nclusters_gp &lt;- df_matrix %&gt;% \n  tsclust(., \n          k = 8L,                 # assuming clusters\n          distance = \"dtw_basic\", # this is dtw score\n          seed = 390,             # to reproduce results\n          type=\"hierarchical\",    # type of clustering\n          control = hierarchical_control(method = \"ward.D\")) # method in hc\n\nclusters_gp\n\nhierarchical clustering with 8 clusters\nUsing dtw_basic distance\nUsing PAM (Hierarchical) centroids\nUsing method ward.D \n\nTime required for analysis:\n   user  system elapsed \n   0.04    0.00    0.05 \n\nCluster sizes with average intra-cluster distance:\n\n  size  av_dist\n1    1 0.000000\n2    3 5.422677\n3    6 8.436258\n4   13 7.564260\n5    2 6.603003\n6    2 8.962541\n7    5 9.061991\n8    1 0.000000"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#a-dendrogram-tree",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#a-dendrogram-tree",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "A dendrogram (tree)",
    "text": "A dendrogram (tree)\n\nfviz_dend(clusters_gp, k = 8, # Cut the tree in groups\n          cex = 0.5, # label size\n          color_labels_by_k = TRUE, # color labels by groups\n          rect = TRUE, # Add rectangle around groups\n          horiz = TRUE, # Make the tree horizontal\n          ylab = \"DTW score\",\n          palette = \"uchicago\")\n\nWarning: `guides(&lt;scale&gt; = FALSE)` is deprecated. Please use `guides(&lt;scale&gt; =\n\"none\")` instead."
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#labeling-countries-based-on-clusters-and-visualizing-each-variable",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#labeling-countries-based-on-clusters-and-visualizing-each-variable",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Labeling countries based on clusters and visualizing each variable",
    "text": "Labeling countries based on clusters and visualizing each variable\nWe are now joining the estimated groups with the data:\n\nGps &lt;- as.data.frame(cutree(clusters_gp, k = 8)) # num of clusters\ncolnames(Gps) &lt;- \"Gp\"\nGps$country &lt;- row.names(Gps)\nrow.names(Gps) &lt;- NULL\n\n\n\n## Getting the clustering info into the original data\ngapminder_Asia &lt;- gapminder %&gt;% \n  filter(continent == \"Asia\") %&gt;% \n  left_join(x=., y=Gps, by = \"country\")\n\ngapminder_Asia\n\n# A tibble: 396 x 7\n   country     continent  year lifeExp      pop gdpPercap    Gp\n   &lt;chr&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt; &lt;int&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.     1\n 2 Afghanistan Asia       1957    30.3  9240934      821.     1\n 3 Afghanistan Asia       1962    32.0 10267083      853.     1\n 4 Afghanistan Asia       1967    34.0 11537966      836.     1\n 5 Afghanistan Asia       1972    36.1 13079460      740.     1\n 6 Afghanistan Asia       1977    38.4 14880372      786.     1\n 7 Afghanistan Asia       1982    39.9 12881816      978.     1\n 8 Afghanistan Asia       1987    40.8 13867957      852.     1\n 9 Afghanistan Asia       1992    41.7 16317921      649.     1\n10 Afghanistan Asia       1997    41.8 22227415      635.     1\n# ... with 386 more rows\n# i Use `print(n = ...)` to see more rows"
  },
  {
    "objectID": "posts/2020-12-16-dtw/2020-12-16-dtw.html#plotting-each-variable-by-group",
    "href": "posts/2020-12-16-dtw/2020-12-16-dtw.html#plotting-each-variable-by-group",
    "title": "Dynamic Time Warping and Hierarchical Clustering with {gapminder}",
    "section": "Plotting each variable by group",
    "text": "Plotting each variable by group\nFollowing plots show the time-series of life expectancy, population and GDP by group:\n\n### Select 15 countries at random to label on plot\nset.seed(123)\n\nselected_countries &lt;- gapminder_Asia %&gt;% \n  group_by(Gp) %&gt;% \n  select(country) %&gt;% \n  unique() %&gt;% \n  sample_n(size = 4, replace = TRUE) %&gt;% \n  ungroup() %&gt;% \n  pull(country) %&gt;% \n  unique()\n\nAdding missing grouping variables: `Gp`\n\nsc_data &lt;- gapminder_Asia %&gt;% \n  filter(year == 1982,\n         country %in% selected_countries)\n\n\n\n### lifeExp\nggplot(data = gapminder_Asia,\n       aes(x = year, y = lifeExp)) +\n  geom_line(aes(group=country), color = \"grey\") +\n  facet_wrap(~ Gp) +\n  geom_line(data = gapminder_Asia %&gt;% \n              filter(country %in% selected_countries),\n            aes(group=country)) +\n  geom_text_repel(data = sc_data,\n            aes(label = country),\n            box.padding = 1,\n            nudge_x = .15,\n            nudge_y = .5,\n            arrow = arrow(length = unit(0.015, \"npc\")),\n            hjust = 0\n            ) +\n  theme_bw()\n\n\n\n### pop\nggplot(data = gapminder_Asia,\n       aes(x = year, y = pop)) +\n  geom_line(aes(group=country), color = \"grey\") +\n  facet_wrap(~ Gp, scales = \"free_y\") +\n  geom_line(data = gapminder_Asia %&gt;% \n              filter(country %in% selected_countries),\n            aes(group=country)) +\n  geom_text_repel(data = sc_data,\n                  aes(label = country),\n                  box.padding = 1,\n                  nudge_x = .15,\n                  nudge_y = .5,\n                  arrow = arrow(length = unit(0.015, \"npc\")),\n                  hjust = 0\n  ) +\n  theme_bw()\n\n\n\n### gdpPercap\npp &lt;- ggplot(data = gapminder_Asia,\n       aes(x = year, y = gdpPercap)) +\n  geom_line(aes(group=country), color = \"grey\") +\n  facet_wrap(~ Gp, scales = \"free_y\") +\n  geom_line(data = gapminder_Asia %&gt;% \n              filter(country %in% selected_countries),\n            aes(group=country)) +\n  geom_text_repel(data = sc_data,\n                  aes(label = country),\n                  box.padding = 1,\n                  nudge_x = .15,\n                  nudge_y = .5,\n                  arrow = arrow(length = unit(0.015, \"npc\")),\n                  hjust = 0\n  ) +\n  theme_bw()\n\nggsave(\"pp.png\", plot=pp, dpi=600)\n\nSaving 7 x 5 in image"
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html",
    "title": "Elevation Maps in R",
    "section": "",
    "text": "In this post I show you how to create aesthetically pleasant and useful maps in R using ground elevation data."
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#getting-the-elevation-data-in-r",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#getting-the-elevation-data-in-r",
    "title": "Elevation Maps in R",
    "section": "Getting the Elevation Data in R",
    "text": "Getting the Elevation Data in R\nI got the elevation data from Geohub which provides the data for Ontario, Canada in the .tif format. The .tif file type can be easily imported in R using the raster package. If you want to use United States data, the elevatr R package can help with that.\nI have downloaded 2 files for Ontario, one each for north and south Ontario, and then unzipped them. Let’s start by loading the libraries and importing the data.\n\n# Load Libraries ----------------------------------------------------------\n\nsuppressPackageStartupMessages( library(raster) )\nsuppressPackageStartupMessages( library(tidyverse) )\nsuppressPackageStartupMessages( library(ggridges) )\nsuppressPackageStartupMessages( library(rayshader) )\nsuppressPackageStartupMessages( library(gganimate) )\nsuppressPackageStartupMessages( library(sf) )\n\n\n\n\n# Load Data ---------------------------------------------------------------\nont_s &lt;- raster(\"PDEM_South.tif\")\n# ont_n &lt;- raster(here::here(\"PDEM_North.tif\"))\n\nNote that I used here::here() to get my file paths. Let’s see what’s in them:\n\nont_s\n\nclass      : RasterLayer \ndimensions : 31655, 55685, 1762708675  (nrow, ncol, ncell)\nresolution : 30, 30  (x, y)\nextent     : 151020, 1821570, 11620380, 12570030  (xmin, xmax, ymin, ymax)\ncrs        : +proj=lcc +lat_0=0 +lon_0=-85 +lat_1=44.5 +lat_2=53.5 +x_0=930000 +y_0=6430000 +datum=NAD83 +units=m +no_defs \nsource     : PDEM_South.tif \nnames      : PDEM_South \n\n# ont_n\n\nThey are clearly raster file types. You can see in the dimensions section that the number of cells (i.e. number of data points) is quite a large number for both layers. This means that if we try to plot these data with a typical RAM size, say 8GB, we’d have a bad time1. So, to create maps we’d need to decrease the size of these raster layers.\nBefore going to the next step, an important thing to note here is that the crs section above indicates that the units of the x, y and elevation coordinates are meters. The elevation is stored here under the names PDEM_South and PDEM_North in the two raster layers."
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#slimming-down-the-raster-data",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#slimming-down-the-raster-data",
    "title": "Elevation Maps in R",
    "section": "Slimming Down the Raster Data",
    "text": "Slimming Down the Raster Data\nThe sampleRegular function from the raster package lets you take a sample of the original raster data by specifying the size argument. I experimented with different sizes, and was satisfied with size=50000, as it provided a good visual quality in the maps. The last argument here is asRaster that returns a raster data when TRUE.\nOnce we get a reduced raster data, we use the rayshader::raster_to_matrix() function to put all the elevation values in a 2D matrix where the 2 dimensions are x and y coordinates. Following shows the results (only the first 5 rows and columns for each layer):\n\nont_s_m &lt;- ont_s %&gt;% \n  raster::sampleRegular(ont_s, size=50000, asRaster=TRUE) %&gt;%\n  rayshader::raster_to_matrix()\n\nont_s_m[1:5, 1:5]\n\n         [,1]     [,2]     [,3]     [,4]     [,5]\n[1,]       NA 345.7590 343.8626 339.1616       NA\n[2,] 341.2442 344.7713 351.7452 340.4780 326.4015\n[3,] 346.9645 350.9861 349.9320 330.7751 336.5002\n[4,] 355.3123 357.0607 337.0629 333.1272 338.1620\n[5,] 358.0299 358.2284 334.0108 329.6138 329.7867\n\n# ont_n_m &lt;- ont_n %&gt;% \n#   raster::sampleRegular(ont_n, size=50000, asRaster=TRUE) %&gt;%\n#   rayshader::raster_to_matrix()\n# \n# ont_n_m[1:5, 1:5]"
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#d-raster-maps-with-rayshader",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#d-raster-maps-with-rayshader",
    "title": "Elevation Maps in R",
    "section": "3D Raster Maps with Rayshader",
    "text": "3D Raster Maps with Rayshader\nWe use the awesome rayshader package here to plot the raster map in 3D.\n\nont_s_m %&gt;%\n  sphere_shade(texture = \"desert\") %&gt;%\n  add_shadow(ray_shade(ont_s_m, zscale = 30), 0.5) %&gt;%\n  add_shadow(ambient_shade(ont_s_m), 0) %&gt;%\n  plot_3d(ont_s_m, zscale = 10, fov = 0,\n          theta = 0, zoom = 0.75, phi = 70,\n          windowsize = c(1000, 800),\n          solid=FALSE)\n\nSys.sleep(0.6)\nrender_snapshot(clear=T, title_text = \"Ontario (South)\",\n                filename=\"ont_s.png\")\n\nrgl::rgl.close()\n\n## For some reason, rayshader is not rendering the snapshot\n## of this map."
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#creating-ridgeline-maps",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#creating-ridgeline-maps",
    "title": "Elevation Maps in R",
    "section": "Creating Ridgeline Maps",
    "text": "Creating Ridgeline Maps\nRaster maps are beautiful but take long time to render. Another technique that can show the elevation data very effectively is a ridgeline plot. I was previously familiar with the ggridges package but was recently reminded of it when I saw the ridgeline plots app made by Andrei Kashcha. So, I decided to use elevation height in the ggridges::geom_ridgeline() function.\nBut a ridgeline plot uses 3 arguments, x, y, and height. So, to proceed, we need to extract these coordinates from the raster files. Again, we use the raster::sampleRegular function for slimming the data, but also use the xy=TRUE option to get the three coordinates:\n\n## Sample 10000 values\ndf_s &lt;- data.frame(sampleRegular(ont_s, 10000, xy=TRUE))\n# df_n &lt;- data.frame(sampleRegular(ont_n, 10000, xy=TRUE))\n\n\n## Rename to 'elevation'\ndf_s &lt;- df_s %&gt;% \n  rename(elevation = PDEM_South)\n\n# df_n &lt;- df_n %&gt;% \n#   rename(elevation = PDEM_North)\n\n\n## Combine the two\ndf &lt;- df_s#bind_rows(df_s, df_n)\n\nhead(df)\n\n       x        y elevation\n1 157335 12563715  341.1952\n2 169995 12563715  354.5818\n3 182655 12563715  364.6080\n4 195285 12563715  336.9090\n5 207945 12563715  328.2127\n6 220605 12563715  320.1098\n\n\nNote that elevation above is not completely NA (you are seeing the first 6 rows only).\n\nMy attempts to use ggridges::geom_ridgeline() were not successful. Instead, the other function, ggridges::geom_density_ridges is what can effectively generate the nice elevation lines for creating the 3D effect that Andrei showed. I learnt this from Travis M. White’s blogpost. I also found great tips for theming the map.\n\n\nPlots\nThe data is ready now, back to making the maps. A first try:\n\nggplot() +\n  geom_density_ridges(data = df,\n                      aes(x, y, \n                          group=y,\n                          height = elevation),\n                      stat = \"identity\",\n                      scale=20) +\n  theme_void() \n\n\n\n\nSee the 3D effect?\nThe scale argument controls the overlap between the ridgelines. I experimented with different values and settled with 20.\nNow with a dark theme:\n\nggplot() +\n  geom_density_ridges(data = df,\n                      aes(x, y, \n                          group=y,\n                          height = elevation),\n                      stat = \"identity\",\n                      scale=20,\n                      fill=\"black\",\n                      color=\"white\") +\n  scale_x_continuous(name = \"Ontario\") +\n  theme_void() +\n  theme(\n             panel.background = element_rect(fill = \"black\"),\n            \n             plot.background = element_rect(fill = \"black\"),\n           \n             axis.title.x = element_text(colour = 'white', \n                                         size = 18))\n\n\n\n\nFor some reason, this reminded me of neon signs. So, I got an idea!"
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#animating-the-ridgeline-map",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#animating-the-ridgeline-map",
    "title": "Elevation Maps in R",
    "section": "Animating the Ridgeline Map",
    "text": "Animating the Ridgeline Map\nLet’s animate the map with colors. For doing so, I create 2 more copies of the data df and then give one color to each (there may be a better way to do this). Then I use transition_reveal to color the lines turn by turn:\n\ncolos = rep(c(\"red\", \"yellow\", \"green\"), each = nrow(df))\n\nretro &lt;- bind_rows(df, df, df) %&gt;% \n  mutate(colorz = colos)\n\nani1 &lt;- ggplot(data = retro ,\n       aes(x, y, \n           group=y,\n           height = elevation))+\n  geom_density_ridges(stat = \"identity\",\n                      scale=20,\n                      fill=\"black\",\n                      aes(color=colorz)) +\n  scale_x_continuous(name = \"Ontario\") +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    panel.background = element_rect(fill = \"black\"),\n    \n    plot.background = element_rect(fill = \"black\"),\n    \n    axis.title.x = element_text(colour = 'white', \n                                size = 18)) +\n    transition_states(colorz,\n                    transition_length = 2,\n                    state_length = 1)\n\nani1\n\n\n\n\nOf course, we can also animate by x or y dimensions:\n\nani2 &lt;- ggplot(data = df,\n       aes(x, y, \n           group=y,\n           height = elevation))+\n  geom_density_ridges(stat = \"identity\",\n                      scale=8,\n                      fill=\"black\",\n                      color = \"white\") +\n  scale_x_continuous(name = \"Ontario\") +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    panel.background = element_rect(fill = \"black\"),\n    \n    plot.background = element_rect(fill = \"black\"),\n    \n    axis.title.x = element_text(colour = 'white', \n                                size = 18)) + \n  transition_manual(x, cumulative = T) + \n  ease_aes('linear')\n\n\nani2\n\n\n\n\nThis ends the blogpost. I hope you’d find something useful here for your mapping needs."
  },
  {
    "objectID": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#footnotes",
    "href": "posts/2020-12-25-elevation-maps-in-r/elevation-maps-in-r.html#footnotes",
    "title": "Elevation Maps in R",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nRead the discussion here: https://stackoverflow.com/questions/61535383/r-runs-out-of-memory-plotting-data-frame-with-ggplot2↩︎"
  },
  {
    "objectID": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html",
    "href": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html",
    "title": "Autocomplete Character/Factor values in RStudio",
    "section": "",
    "text": "This post is based on Ayush Patel’s post that describes the use of the patch package that lets you choose from a menu of character/factor values in RStudio."
  },
  {
    "objectID": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html#credit",
    "href": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html#credit",
    "title": "Autocomplete Character/Factor values in RStudio",
    "section": "",
    "text": "This post is based on Ayush Patel’s post that describes the use of the patch package that lets you choose from a menu of character/factor values in RStudio."
  },
  {
    "objectID": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html#autocomplete-in-action",
    "href": "posts/2021-01-01-autocomplete-character-factor-values-in-rstudio/2021-01-01-autocomplete-character-factor-values-in-rstudio.html#autocomplete-in-action",
    "title": "Autocomplete Character/Factor values in RStudio",
    "section": "Autocomplete in action",
    "text": "Autocomplete in action\nNow we can easily select the desired character/factor value from the autocomplete menu. Let’s first load a data set and see the factor values in it.\n\ndata(\"chickwts\")\n\nchickwts\n\n   weight      feed\n1     179 horsebean\n2     160 horsebean\n3     136 horsebean\n4     227 horsebean\n5     217 horsebean\n6     168 horsebean\n7     108 horsebean\n8     124 horsebean\n9     143 horsebean\n10    140 horsebean\n11    309   linseed\n12    229   linseed\n13    181   linseed\n14    141   linseed\n15    260   linseed\n16    203   linseed\n17    148   linseed\n18    169   linseed\n19    213   linseed\n20    257   linseed\n21    244   linseed\n22    271   linseed\n23    243   soybean\n24    230   soybean\n25    248   soybean\n26    327   soybean\n27    329   soybean\n28    250   soybean\n29    193   soybean\n30    271   soybean\n31    316   soybean\n32    267   soybean\n33    199   soybean\n34    171   soybean\n35    158   soybean\n36    248   soybean\n37    423 sunflower\n38    340 sunflower\n39    392 sunflower\n40    339 sunflower\n41    341 sunflower\n42    226 sunflower\n43    320 sunflower\n44    295 sunflower\n45    334 sunflower\n46    322 sunflower\n47    297 sunflower\n48    318 sunflower\n49    325  meatmeal\n50    257  meatmeal\n51    303  meatmeal\n52    315  meatmeal\n53    380  meatmeal\n54    153  meatmeal\n55    263  meatmeal\n56    242  meatmeal\n57    206  meatmeal\n58    344  meatmeal\n59    258  meatmeal\n60    368    casein\n61    390    casein\n62    379    casein\n63    260    casein\n64    404    casein\n65    318    casein\n66    352    casein\n67    359    casein\n68    216    casein\n69    222    casein\n70    283    casein\n71    332    casein\n\n\nNow, do a filter on the feed:\n\nAnd the result is:\n\nchickwts %&gt;% \n  filter(feed == \"linseed\")\n\n   weight    feed\n1     309 linseed\n2     229 linseed\n3     181 linseed\n4     141 linseed\n5     260 linseed\n6     203 linseed\n7     148 linseed\n8     169 linseed\n9     213 linseed\n10    257 linseed\n11    244 linseed\n12    271 linseed"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html",
    "title": "Making a History Table of Discover Canada in R",
    "section": "",
    "text": "Discover Canada is a study guide that is a required read for anyone preparing for the Canadian citizenship test. It contains information on Canadian government, culture and geography.\nThere is also a lot of history sprinkled throughout the text, containing the exact year when something important happened. For example, the current border between Canada and The United States of America was partly a result of the 1812 war between the two countries."
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#can-i-use-r-to-create-a-history-timeline",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#can-i-use-r-to-create-a-history-timeline",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Can I use R to create a history timeline?",
    "text": "Can I use R to create a history timeline?\nAs a new reader, trying to remember all of the Canadian histoy seems very daunting. I personally prefer a timeline with year and what happened information. So, I initially thought to create something like that by hand, but then:\n\nI recalled that Discover Canada is also available as a pdf and I could potentially import it in R as text\nI had heard the term corpus used for text documents in R, and thought that I could maybe convert the imported text into a corpus. A recent R Ladies webinar showed exactly how (Thank you R-Ladies Tunis!)\nWith text in R, I could use the tidytext package to extract the sentences and then get the history by years\nFinally, I could create a table with history in each year in increasing order using reactable package. My starting point here was Tom Mock’s blog (thanks Tom!)"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-1-from-pdf-to-dataframe",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-1-from-pdf-to-dataframe",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Step 1: From pdf to dataframe",
    "text": "Step 1: From pdf to dataframe\nI started by loading the pdftools and quanteda libraries for reading the Discover Canada pdf file and converting it into a corpus.\n\nsuppressPackageStartupMessages(library(pdftools))\nsuppressPackageStartupMessages(library(quanteda)) \n\nI first downloaded the large print pdf file from the Discover Canada website. Following shows the page 13 from the pdf:\n\n\n\nPage 13 from the Large Print pdf of Discover Canada\n\n\nNext, I read this file in R:\n\npdf_text &lt;- pdf_text(pdf = \"discover-large.pdf\")\n\nhead(pdf_text, 3)\n\n[1] \"             STUDY GUIDE\\r\\n           Discover Canada\\r\\nThe Rights and Responsibilities of Citizenship\\r\\n          LARGE PRINT\\r\\n\"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n[2] \"     2\\r\\n\\t\\r  \\r\\n\"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n[3] \"The Oath of Citizenship\\r\\nI swear (or affirm)\\r\\nThat I will be faithful\\r\\nAnd bear true allegiance\\r\\nTo Her Majesty Queen Elizabeth the Second\\r\\nQueen of Canada\\r\\nHer Heirs and Successors\\r\\nAnd that I will faithfully observe\\r\\nThe laws of Canada\\r\\nAnd fulfil my duties as a Canadian citizen.\\r\\nLe serment de citoyenneté\\r\\nJe jure (ou j’affirme solennellement)\\r\\nQue je serai fidèle\\r\\nEt porterai sincère allégeance\\r\\nà Sa Majesté la Reine Elizabeth Deux\\r\\nReine du Canada\\r\\nÀ ses héritiers et successeurs\\r\\nQue j’observerai fidèlement les lois du Canada\\r\\nEt que je remplirai loyalement mes obligations\\r\\nde citoyen canadien.\\r\\n                                   3\\r\\n\\t\\r  \\r\\n\" \n\n\nThe next step was to convert the raw text into a corpus. This is possible with the corpus() function from the quanteda package:\n\ndc_corpus &lt;- corpus(pdf_text)\n\ndocvars(dc_corpus)\n\ndata frame with 0 columns and 129 rows\n\n\nThe quanteda::docvars() function lets you find the existing variables and create new variables for the documents in a corpus. There were 129 text “documents” in dc_corpus (you can find it with length(dc_corpus)). We know that there is only 1 document that I am using here, but the pdftools::pdftext() function split the original text into 129 parts. That’s why the corpus now has 129 documents.\n\nInterlude: Tokenization and Visualization of Text Data\nNow that the data is living in a corpus, there is a lot that I can do in terms of text analysis. For instance, this awesome post by the R-Ladies presenter, Cosima Meyer introduces the terms for natural language processing and also shows how to clean and visualize text data. Based on that code, I produced a word cloud in three steps below, all powered by the quanteda package:\n\nPre-process the text by removing punctuation, symbols and URL, and splitting the hyphenated words. This pre-processed result is called as tokens.\n\n\n# Text pre-processing\ndc_tokens &lt;- tokens(\n    # Takes the corpus\n    dc_corpus,\n    # Remove punctuation\n    remove_punct = TRUE,\n    # Remove symbols\n    remove_symbols = TRUE,\n    # Remove URL\n    remove_url = TRUE,\n    # Split up hyphenated words\n    split_hyphens = TRUE\n  )\n\n\nhead(dc_tokens, 3)\n\nTokens consisting of 3 documents.\ntext1 :\n [1] \"STUDY\"            \"GUIDE\"            \"Discover\"         \"Canada\"          \n [5] \"The\"              \"Rights\"           \"and\"              \"Responsibilities\"\n [9] \"of\"               \"Citizenship\"      \"LARGE\"            \"PRINT\"           \n\ntext2 :\n[1] \"2\"\n\ntext3 :\n [1] \"The\"         \"Oath\"        \"of\"          \"Citizenship\" \"I\"          \n [6] \"swear\"       \"or\"          \"affirm\"      \"That\"        \"I\"          \n[11] \"will\"        \"be\"         \n[ ... and 87 more ]\n\n\n\nCreate a document-feature matrix (DFM). DFM estimates the frequency of each word (‘feature’) across all the text components (‘documents’). While creating DFM you can also stem words. Stemming refers to finding the common root of several words. For example, government and governor have the same root govern. Moreover, you can remove the stopwords that are common words in the language e.g. the, are, etc.\n\n\n# Calculate a document-feature matrix (DFM)\n\ndc_dfm &lt;- dfm(\n  # Take the token object\n  dc_tokens,\n  # Lower the words\n  tolower = TRUE,\n  # Get the stem of the words\n  stem = TRUE,\n  # Remove stop words\n  remove = stopwords(\"english\")\n)\n\ndc_dfm\n\nDocument-feature matrix of: 129 documents, 3,008 features (97.7% sparse).\n       features\ndocs    studi guid discov canada right respons citizenship larg print 2\n  text1     1    1      1      1     1       1           1    1     1 0\n  text2     0    0      0      0     0       0           0    0     0 1\n  text3     0    0      0      4     0       0           1    0     0 0\n  text4     0    0      0      5     1       0           1    0     0 0\n  text5     0    0      0      5     2       2           4    0     0 0\n  text6     0    1      0      2     2       1           1    0     0 0\n[ reached max_ndoc ... 123 more documents, reached max_nfeat ... 2,998 more features ]\n\n\n\nCreate a wordcloud:\n\n\nsuppressPackageStartupMessages(library(wesanderson))\n\ntextplot_wordcloud(\n  # Load the DFM object\n  dc_dfm,\n  # Define the minimum number the words have to occur\n  min_count = 3,\n  # Define the maximum number the words can occur\n  max_words = 500,\n  # Define a color\n  color = wes_palette(\"Royal1\")\n  \n)\n\n\n\n\nAs expected, canada was the most common word across all the paragraphs of text.\nGoing back to our task of creating a dataframe out of the corpus, the following code shows how to do that (thanks to this answer on stackoverflow):\n\nsuppressPackageStartupMessages(library(tidyverse))\n# Corpus to dataframe\ndc_df &lt;- data.frame(text = sapply(dc_corpus, as.character), \n           stringsAsFactors = FALSE, row.names = NULL) %&gt;% \n         as_tibble()\n\nhead(dc_df, 3)\n\n# A tibble: 3 x 1\n  text                                                                          \n  &lt;chr&gt;                                                                         \n1 \"             STUDY GUIDE\\n           Discover Canada\\nThe Rights and Respons~\n2 \"     2\\n\\t\\n  \\n\"                                                            \n3 \"The Oath of Citizenship\\nI swear (or affirm)\\nThat I will be faithful\\nAnd b~"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-2-split-the-text-paragraph-in-each-row-into-sentences",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-2-split-the-text-paragraph-in-each-row-into-sentences",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Step 2: Split the text paragraph in each row into sentences",
    "text": "Step 2: Split the text paragraph in each row into sentences\nI used the tidytext package for this step:\n\nsuppressPackageStartupMessages(library(tidytext))\n## divide into sentences\ndc_df_sent &lt;- dc_df %&gt;% \n  unnest_tokens(output = sentence, input = text, token = \"sentences\")\n\nhead(dc_df_sent, 3)\n\n# A tibble: 3 x 1\n  sentence                                                                      \n  &lt;chr&gt;                                                                         \n1 study guide            discover canada the rights and responsibilities of cit~\n2 2                                                                             \n3 the oath of citizenship i swear (or affirm) that i will be faithful and bear ~"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-3-find-the-sentences-containing-years",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-3-find-the-sentences-containing-years",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Step 3: Find the sentences containing years",
    "text": "Step 3: Find the sentences containing years\nI found all those sentences that contained a four-digit number that indicated a year in the text. Then I filtered out all other sentences and sorted the dataframe by year:\n\n## Find which sentence has a 4 digit number\ndc_df_year &lt;- dc_df_sent %&gt;% \n  mutate(\n    has_a_num = str_detect(string = sentence, pattern = \"[[:digit:]]{4}\")\n  ) %&gt;% \n  filter(has_a_num == TRUE) %&gt;% \n  mutate(\n    year = str_extract(string = sentence, pattern = \"[[:digit:]]{4}\") %&gt;% \n      as.numeric()\n  ) %&gt;% \n  select(year, sentence) %&gt;% \n  arrange(year) \n\n\nhead(dc_df_year, 2)\n\n# A tibble: 2 x 2\n   year sentence                                                                \n  &lt;dbl&gt; &lt;chr&gt;                                                                   \n1  1215 together, these secure for canadians an 800-year old tradition of order~\n2  1497 picture: (top) indian encampment, fur trade era picture: (right) john c~"
  },
  {
    "objectID": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-4-create-a-table-of-year-and-relevant-history",
    "href": "posts/2021-02-07-making-a-history-table-from-discover-canada-in-r/making-a-history-table-from-discover-canada-in-r.html#step-4-create-a-table-of-year-and-relevant-history",
    "title": "Making a History Table of Discover Canada in R",
    "section": "Step 4: Create a table of year and relevant history:",
    "text": "Step 4: Create a table of year and relevant history:\nFinally, I used the reactable package to create an interactive table that contained year as a group. Clicking on a year group reveals history in one or more sentences from Discover Canada:\n\nsuppressPackageStartupMessages(library(reactable))\n\nreactable(\n  dc_df_year,\n  groupBy = \"year\",\n  searchable = TRUE,\n  filterable = TRUE,\n  resizable = TRUE,\n  onClick = \"expand\",\n  showPageSizeOptions = TRUE,\n  columns = list(\n    year = colDef(name = \"Year\", maxWidth = 250),\n    sentence = colDef( name = \"What happened?\")\n   ),\n  theme = reactableTheme(backgroundColor = \"#eadbcb\")\n)\n\n\n\n\n\n\nI am now ready to delve into the Discover Canada study guide further. Ideally, I want to extract the most useful phrases from each sentence for a given year, but at this point I do not know the best way to do that programmatically. If you have any ideas, please share with me on twitter."
  },
  {
    "objectID": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html",
    "href": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html",
    "title": "Gipps Model in R, Rcpp, and Julia",
    "section": "",
    "text": "Car-following behaviour refers to the motion of a vehicle that follows another vehicle in the same lane. Generally, car-following models are used in simulation software that provide other models as well (e.g., lane change model). However, to understand the outputs of a model, it is a good idea to run the model in a programming environment in isolation. This blog post is about running a car-following model - Gipps car-following model (Gipps 1981)- in R and Julia programming languages.\n\n\n\n\nThe equation for Gipps model is shown below. To learn more, see this wikipedia article. You may also be interested in listening to Dr. Martin Treiber’s lecture on Gipps model (see the right bar).\n\nv_n(t+\\tau) = {min} \\biggl\\{v_n(t) + 2.5 a_n\\tau (1-v_n(t)/V_n){(0.025+v_n(t)/V_n)}^{1/2}, \\\\ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ b_n\\tau+\\sqrt{b_n^2\\tau^2 -b_n [ 2[x_{n-1}(t)-s_{n-1}-x_n(t)] - v_n(t)\\tau- v_{n-1}(t)^2\\hat{b}]}\\biggr\\}\n\nIn the following sections, I will define and apply the functions for Gipps model in both R and Julia. Julia is a fast programming language and could be a good environment to implement car-following models for numerical simulations and calibration. But I am pretty new to using Julia, so I write R first and then convert the syntax to Julia. You will see side by side code for both."
  },
  {
    "objectID": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#introduction",
    "href": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#introduction",
    "title": "Gipps Model in R, Rcpp, and Julia",
    "section": "",
    "text": "Car-following behaviour refers to the motion of a vehicle that follows another vehicle in the same lane. Generally, car-following models are used in simulation software that provide other models as well (e.g., lane change model). However, to understand the outputs of a model, it is a good idea to run the model in a programming environment in isolation. This blog post is about running a car-following model - Gipps car-following model (Gipps 1981)- in R and Julia programming languages.\n\n\n\n\nThe equation for Gipps model is shown below. To learn more, see this wikipedia article. You may also be interested in listening to Dr. Martin Treiber’s lecture on Gipps model (see the right bar).\n\nv_n(t+\\tau) = {min} \\biggl\\{v_n(t) + 2.5 a_n\\tau (1-v_n(t)/V_n){(0.025+v_n(t)/V_n)}^{1/2}, \\\\ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ b_n\\tau+\\sqrt{b_n^2\\tau^2 -b_n [ 2[x_{n-1}(t)-s_{n-1}-x_n(t)] - v_n(t)\\tau- v_{n-1}(t)^2\\hat{b}]}\\biggr\\}\n\nIn the following sections, I will define and apply the functions for Gipps model in both R and Julia. Julia is a fast programming language and could be a good environment to implement car-following models for numerical simulations and calibration. But I am pretty new to using Julia, so I write R first and then convert the syntax to Julia. You will see side by side code for both."
  },
  {
    "objectID": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#load-libraries",
    "href": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#load-libraries",
    "title": "Gipps Model in R, Rcpp, and Julia",
    "section": "Load libraries",
    "text": "Load libraries\n\n\n\nR\nlibrary(tidyverse)\nlibrary(microbenchmark)\n\n\n \n\n\nJulia\nusing CSV\nusing DataFrames\nusing BenchmarkTools"
  },
  {
    "objectID": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#load-data",
    "href": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#load-data",
    "title": "Gipps Model in R, Rcpp, and Julia",
    "section": "Load Data",
    "text": "Load Data\nI have a dataset in a csv file that contains the positions and speeds of a car following another car (based on the cleaned I80 data from Montanino and Punzo 2015). I load this csv file separately in both R and Julia\n\n\n\nR\ndfn1_r &lt;- read_csv(\"dfn1.csv\") %&gt;% select(-X1)\n\nhead(dfn1_r, 3)\n\n# A tibble: 3 x 9\n  Vehicle.ID  Time Local.Y PrecVehLocalY  svel PrecVe~1       dV frspa~2 PrecV~3\n       &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1         11   0      50.2          66.2  4.42     4.42 -0.00292    11.6    4.36\n2         11   0.1    50.6          66.6  4.42     4.42 -0.00103    11.6    4.36\n3         11   0.2    51.1          67.1  4.42     4.42  0.00108    11.6    4.36\n# ... with abbreviated variable names 1: PrecVehVel, 2: frspacing,\n#   3: PrecVehLength\n\n\n\n \n\n\nJulia\ndfn1_julia = DataFrame(CSV.File(\"dfn1.csv\"));\n\ndfn1_julia = select!(dfn1_julia, Not(:Column1));\n\nfirst(dfn1_julia, 3)\n\n3×9 DataFrame\n Row │ Vehicle.ID  Time     Local.Y  PrecVehLocalY  svel     PrecVehVel  dV    ⋯\n     │ Int64       Float64  Float64  Float64        Float64  Float64     Float ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │         11      0.0  50.2051        66.1681  4.42008     4.423    -0.00 ⋯\n   2 │         11      0.1  50.6473        66.6105  4.42202     4.42305  -0.00\n   3 │         11      0.2  51.0897        67.0528  4.42416     4.42308   0.00\n                                                               3 columns omitted"
  },
  {
    "objectID": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#defining-the-function-for-gipps-model",
    "href": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#defining-the-function-for-gipps-model",
    "title": "Gipps Model in R, Rcpp, and Julia",
    "section": "Defining the function for Gipps Model",
    "text": "Defining the function for Gipps Model\nFollowing is my implementation of functions for the Gipps model. I won’t go into the details of each line in the functions. Feel free to reach out if you have any questions/suggestions to improve these functions.\nNote that I also implemented another function in R where I re-wrote the for loop as a function in Rcpp. Again, the reason is to speed up the calculations.\n\nRJuliaRcpp\n\n\n\nsimulate_gipps_r &lt;- function(resolution, N, dfn1,\n                             xn1, vn1, xn_first, vn_first, ln, an,\n                             Vn, tau, bn_const, bcap) {\n  ####### Time #############################################\n\n  # Last time frame of the simulation:\n  last_time &lt;- (nrow(dfn1) - 1) * resolution\n\n  # Time vector:\n  Time &lt;- seq(from = 0, to = last_time, by = resolution)\n\n  # Length of the Time vector\n  time_length &lt;- length(Time)\n\n\n\n  list_of_N_veh &lt;- vector(mode = \"list\", length = N)\n\n\n\n\n\n  for (n in seq_along(list_of_N_veh)) {\n\n    ####### Assign names to Lead Vehicle Parameters ##########\n\n    if (n == 1L) {\n\n      # Lead vehicle position\n      xn1 &lt;- dfn1[[xn1]]\n\n      # Lead vehicle speed\n      vn1 &lt;- dfn1[[vn1]]\n    }\n\n    ln1 &lt;- ln[[n]]\n\n    ####### Allocate Vectors ##################################\n\n    # free-flow speed\n    vn_ff &lt;- rep(NA_real_, time_length)\n\n    # car-following speed\n    vn_cf &lt;- rep(NA_real_, time_length)\n\n    # speed\n    vn &lt;- rep(NA_real_, time_length)\n\n    # position\n    xn &lt;- rep(NA_real_, time_length)\n\n    # spacing\n    sn &lt;- rep(NA_real_, time_length)\n\n    # speed difference\n    deltav &lt;- rep(NA_real_, time_length)\n\n    # acceleration rate\n    bn &lt;- rep(NA_real_, time_length)\n\n    ######## Initial values for Following vehicle ##################################\n\n    # speed\n    vn_ff[1] &lt;- vn_first[[n]]\n    vn_cf[1] &lt;- vn_first[[n]]\n    vn[1] &lt;- vn_first[[n]]\n\n    # position\n    xn[1] &lt;- xn_first[[n]]\n\n    # spacing\n    sn[1] &lt;- xn1[1] - xn_first[[n]]\n\n    # speed difference\n    deltav[1] &lt;- vn_first[[n]] - vn1[1]\n\n    ###### Gipps Calculations ############################\n\n    for (t in 2:(time_length - 1)) {\n\n      ## free flow\n      vn_ff[t] &lt;- vn[t - 1] +\n        (2.5 * an * tau * (1 - (vn[t - 1]) / Vn)) * ((0.025 + (vn[t - 1] / Vn))^(0.5))\n\n      ## car following\n      bcap_part_cf &lt;- (((vn1[t - 1])^2) / bcap)\n\n      vn_cf[t] &lt;- (bn_const * tau) +\n        sqrt(\n          ((bn_const^2) * (tau^2)) - (bn_const * (2 * (xn1[t - 1] - ln1 - xn[t - 1]) - (vn[t - 1] * tau) - bcap_part_cf))\n        )\n\n      ## gipps speed\n      if (is.na(vn1[t - 1])) {\n        vn[t] &lt;- vn_ff[t]\n      } else {\n        vn[t] &lt;- min(vn_ff[t], vn_cf[t])\n      }\n\n      ### if the speed is negative, make it zero\n      vn[t] &lt;- ifelse(vn[t] &lt; 0, 0, vn[t])\n\n      ## acceleration\n      bn[t - 1] &lt;- (vn[t] - vn[t - 1]) / (resolution)\n\n      ## position\n      xn[t] &lt;- xn[t - 1] + (vn[t - 1] * resolution) + (0.5 * bn[t - 1] * (resolution)^2)\n\n      # spacing\n      sn[t] &lt;- xn1[t] - xn[t] - ln1\n\n      # speed difference\n      deltav[t] &lt;- vn[t] - vn1[t]\n    }\n    # ################## Result in a dataframe ###################################\n    result_dfn &lt;- data.frame(fvn = n, Time, xn1, vn1, ln1, bcap, bn, xn, vn_ff, vn_cf, vn, sn, deltav)\n\n    list_of_N_veh[[n]] &lt;- result_dfn\n\n    xn1 &lt;- xn\n    vn1 &lt;- vn\n  }\n\n  result &lt;- do.call(\"rbind\", list_of_N_veh)\n\n\n  return(result)\n}\n\n\n\n\nfunction simulate_gipps_julia(resolution, N, dfn1, \n    xn1, vn1, xn_first, vn_first, ln, an, \n    Vn, tau, bn_const, bcap)\n  \n    ####### Time #############################################\n\n    # Last time frame of the simulation:\n    last_time = (nrow(dfn1) - 1) * resolution\n\n    # Time vector:\n    Time = collect( range(0, stop = last_time, step = resolution) )\n\n    # Length of the Time vector\n    time_length = length(Time)\n\n    list_of_N_veh = Vector{Union{DataFrame, Missing}}(missing, N)\n    # sizehint!(list_of_N_veh, N)\n\n    for n in 1:length(list_of_N_veh)\n        ####### Assign names to Lead Vehicle Parameters ##########\n        \n        if (n == 1) \n            \n            # Lead vehicle position\n            xn1 = dfn1[!, xn1]\n            \n            # Lead vehicle speed\n            vn1 = dfn1[!, vn1]\n            \n        end\n\n        ln1 = ln[n]\n\n        ####### Allocate Vectors ##################################\n\n        # free-flow speed\n        vn_ff = Vector{Union{Float64, Missing}}(missing, time_length)\n        \n        # car-following speed\n        vn_cf = Vector{Union{Float64, Missing}}(missing, time_length)\n        \n        # speed\n        vn = Vector{Union{Float64, Missing}}(missing, time_length)\n        \n\n        # position\n        xn = Vector{Union{Float64, Missing}}(missing, time_length)\n        \n\n        # spacing\n        sn = Vector{Union{Float64, Missing}}(missing, time_length)\n        \n\n        # speed difference\n        deltav = Vector{Union{Float64, Missing}}(missing, time_length)\n        \n\n        # acceleration rate\n        bn = Vector{Union{Float64, Missing}}(missing, time_length)\n        \n\n            ######## Initial values for Following vehicle ##################################\n\n        # speed\n        vn_ff[1] = vn_first[n]\n        vn_cf[1] = vn_first[n]\n        vn[1] = vn_first[n]\n\n        # position\n        xn[1] = xn_first[n]\n\n        # spacing\n        sn[1] = xn1[1] - xn_first[n]\n\n        # speed difference\n        deltav[1] = vn_first[n] - vn1[1]\n\n        ###### Gipps Calculations ############################\n        \n        for t in 2:(time_length-1)\n\n            ## free flow\n            vn_ff[t] = vn[t-1] + (2.5 * an * tau * (1 - (vn[t-1])/Vn)) * ((0.025 + (vn[t-1]/Vn))^(0.5))\n\n            ## car following\n            bcap_part_cf = (((vn1[t-1])^2)/bcap)\n\n            vn_cf[t] = (bn_const * tau) + sqrt(((bn_const^2) * (tau^2)) - (bn_const * (2 * (xn1[t-1] - ln1 - xn[t-1]) - (vn[t-1] * tau) - bcap_part_cf)))\n\n            ## gipps speed\n            if (ismissing.(vn1[t-1]))\n            \n            vn[t] = vn_ff[t]\n            \n            else \n            \n            vn[t] = min(vn_ff[t], vn_cf[t] )\n            \n            end\n\n            ### if the speed is negative, make it zero\n            vn[t] = ifelse(vn[t] &lt; 0, 0, vn[t])\n            \n            \n            ## acceleration\n            bn[t-1] = (vn[t] - vn[t-1])/(resolution)\n            \n            \n            \n            ## position\n            xn[t] = xn[t-1] + (vn[t-1] * resolution) + (0.5 * bn[t-1] * (resolution)^2)\n            \n            \n            # spacing\n            sn[t] = xn1[t] - xn[t] - ln1\n            \n            # speed difference\n            deltav[t] = vn[t] - vn1[t]\n\n        end\n\n    # ################## Result in a dataframe ###################################\n        result_dfn = DataFrame(fvn=n, Time =Time, xn1=xn1, vn1=vn1, ln1=ln1, bn=bn, xn=xn, vn=vn, sn=sn, deltav=deltav)\n        \n        \n        list_of_N_veh[n] = result_dfn\n        \n        xn1 = xn\n        vn1 = vn\n\n    end\n\n    result = reduce(vcat, list_of_N_veh)\n\n    return result\n\nend\n\nsimulate_gipps_julia (generic function with 1 method)\n\n\n\n\n\n#include &lt;cmath&gt;\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n\n\n// [[Rcpp::export]]\nDataFrame for_loop_gipps(double resolution,\n                         int n,\n                         int time_length,\n                         double tau,\n                         double an,\n                         double bn_const,\n                         double Vn,\n                         double bcap,\n                         double ln1,\n\n                         NumericVector Time,\n                         NumericVector vn_ff,\n                         NumericVector vn_cf,\n                         NumericVector vn,\n                         NumericVector vn1,\n                         NumericVector sn,\n                         NumericVector xn,\n                         NumericVector xn1,\n                         NumericVector deltav,\n                         NumericVector bn\n) {\n\n\n  for(int t = 1; t &lt; (time_length-1); t++) {\n\n    // ## free flow\n    vn_ff[t] = vn[t-1] + (2.5 * an * tau * (1 - (vn[t-1])/Vn)) * ((0.025 + pow((vn[t-1]/Vn), 0.5)));\n\n    // if (Rcpp::NumericVector::is_na(vn1[t-1])) {\n    //\n    //   vn1[t-1] = 0;\n    //\n    // } else {\n    //\n    //   vn1[t-1] = vn1[t-1];\n    //\n    //   }\n\n    // ## car following\n    vn_cf[t] = (bn_const * tau) + sqrt(\n      (pow(bn_const,2) * pow(tau,2)) - (bn_const * (2 * (xn1[t-1] - ln1 - xn[t-1]) - (vn[t-1] * tau) - (pow((vn1[t-1]),2)/bcap)))\n    );\n\n    // ## gipps speed\n\n    if (Rcpp::NumericVector::is_na(vn1[t-1])){\n\n      vn[t] = vn_ff[t];\n\n    } else {\n\n      if (vn_ff[t] &lt; vn_cf[t]){\n\n        vn[t] = vn_ff[t];\n\n      } else {\n\n        vn[t] = vn_cf[t];\n\n        }\n\n    }\n\n    // ### if the speed is negative, make it zero\n\n    if (vn[t] &lt; 0) {\n\n      vn[t] = 0;\n\n    } else {\n\n      vn[t] = vn[t];\n\n    }\n\n    // ## acceleration\n    bn[t-1] = (vn[t] - vn[t-1])/(resolution);\n\n    // ## position\n    xn[t] = xn[t-1] + (vn[t-1] * resolution) + (0.5 * bn[t-1] * pow(resolution, 2));\n\n    // # spacing\n    sn[t] = xn1[t] - xn[t];\n\n    // # speed difference\n    deltav[t] = vn[t] - vn1[t];\n\n\n  }\n\n  DataFrame df = DataFrame::create(Named(\"fvn\") = n,\n                                   Named(\"Time\") = Time,\n                                   Named(\"xn1\") = xn1,\n                                   Named(\"vn1\") = vn1,\n                                   Named(\"ln1\") = ln1,\n                                   Named(\"bn\") = bn,\n                                   Named(\"xn\") = xn,\n                                   Named(\"vn\") = vn,\n                                   Named(\"sn\") = sn,\n                                   Named(\"deltav\") = deltav,\n                                   Named(\"vn_ff\") = vn_ff,\n                                   Named(\"vn_cf\") = vn_cf);\n\n  return df;\n\n\n}\n\n\nsimulate_gipps_rcpp &lt;- function(\n\n  ############## Simulation Parameters #######################\n  resolution, # Duration of a time frame. Typical values are 0.1, 0.5, 1.0 s. Double. Must match with the resolution of the observed lead vehicle data dfn1\n  N, # Number of Following Vehicles in the same lane (platoon). Integer.\n\n\n  ############### Lead Vehicle Data #########################\n  dfn1, # Name (unquoted) of the dataframe that contains lead vehicle data.\n  xn1, # Name of the column in dfn1 that contains lead vehicle position. Character.\n  vn1, # Name of the column in dfn1 that contains lead vehicle speed. Character.\n\n\n\n  ############### Following Vehicle Data ####################\n  xn_first, # First value of vehicle position of each of the following vehicles. A list of doubles with size equal to N.\n  vn_first, # First value of vehicle speed of each of the following vehicles. A list of doubles with size equal to N.\n  ln, # Effective size of each of the lead vehicles i.e. vehicle length plus margin of safety. A list of doubles with size equal to N.\n\n\n  ############### Model Parameters ##########################\n  an, # Maximum acceleration which the driver wishes to undertake m/s2. Double.\n  Vn, # Desired speed/speed at which driver  wishes to travel m/s. Double.\n  tau, # Reaction Time s. Double.\n  bn_const, # Most severe braking that the driver wishes to undertake m/s2. Double and Negative.\n  bcap # An estimate of lead vehicle deceleration m/s2. Double and Negative.\n\n\n\n) {\n\n  ####### Time #############################################\n\n  # Last time frame of the simulation:\n  last_time &lt;- (nrow(dfn1) - 1) * resolution\n\n  # Time vector:\n  Time &lt;- seq(from = 0, to = last_time, by = resolution)\n\n  # Length of the Time vector\n  time_length &lt;- length(Time)\n\n\n\n\n\n\n  list_of_N_veh &lt;- vector(mode = \"list\", length = N)\n\n\n  for (n in seq_along(list_of_N_veh)) {\n\n    ####### Assign names to Lead Vehicle Parameters ##########\n\n    if (n == 1L) {\n\n      # Lead vehicle position\n      xn1 &lt;- dfn1[[xn1]]\n\n      # Lead vehicle speed\n      vn1 &lt;- dfn1[[vn1]]\n\n    }\n\n    ln1 &lt;- ln[[n]]\n\n    ####### Allocate Vectors ##################################\n\n    # free-flow speed\n    vn_ff &lt;- rep(NA_real_, time_length)\n\n    # car-following speed\n    vn_cf &lt;- rep(NA_real_, time_length)\n\n    # speed\n    vn &lt;- rep(NA_real_, time_length)\n\n    # position\n    xn &lt;- rep(NA_real_, time_length)\n\n    # spacing\n    sn &lt;- rep(NA_real_, time_length)\n\n    # speed difference\n    deltav &lt;- rep(NA_real_, time_length)\n\n    # acceleration rate\n    bn &lt;- rep(NA_real_, time_length)\n\n    ######## Initial values for Following vehicle ##################################\n\n    # speed\n    vn_ff[1] &lt;- vn_first[[n]]\n    vn_cf[1] &lt;- vn_first[[n]]\n    vn[1] &lt;- vn_first[[n]]\n\n    # position\n    xn[1] &lt;- xn_first[[n]]\n\n    # spacing\n    sn[1] &lt;- xn1[1] - xn_first[[n]]\n\n    # speed difference\n    deltav[1] &lt;- vn_first[[n]] - vn1[1]\n\n    ###### Gipps Calculations ############################\n\n    result_dfn &lt;- for_loop_gipps(resolution,\n                                 n,\n                                 time_length,\n                                 tau,\n                                 an,\n                                 bn_const,\n                                 Vn,\n                                 bcap,\n                                 ln1,\n\n                                 Time,\n                                 vn_ff,\n                                 vn_cf,\n                                 vn,\n                                 vn1,\n                                 sn,\n                                 xn,\n                                 xn1,\n                                 deltav,\n                                 bn\n    )\n\n    ################## Result in a dataframe ###################################\n\n    list_of_N_veh[[n]] &lt;- result_dfn\n\n    xn1 &lt;- result_dfn$xn\n    vn1 &lt;- result_dfn$vn\n\n\n  }\n\n  result &lt;- do.call(\"rbind\", list_of_N_veh)\n\n  # return the result dataframe\n  return(result)\n\n}"
  },
  {
    "objectID": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#running-the-function-on-data",
    "href": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#running-the-function-on-data",
    "title": "Gipps Model in R, Rcpp, and Julia",
    "section": "Running the function on data",
    "text": "Running the function on data\nThe functions are defined above. Let’s run them now with the data of a single car-following pair.\n\nRRcppJulia\n\n\n\nresult_r &lt;- simulate_gipps_r(0.1, \n                         1, \n                         \n                         dfn1_r,\n                         'PrecVehLocalY',\n                         'PrecVehVel',\n                         \n                         list(dfn1_r$Local.Y[1]), \n                         list(dfn1_r$svel[1]), \n                         list(unique(dfn1_r$PrecVehLength)), \n                         \n                         2, \n                         max(dfn1_r$svel), \n                         1.2, \n                         -1.5, \n                         -2)\n\nhead(result_r, 3)\n\n  fvn Time      xn1     vn1    ln1 bcap           bn       xn    vn_ff    vn_cf\n1   1  0.0 66.16815 4.42300 4.3591   -2  4.708065444 50.20508 4.420080 4.420080\n2   1  0.1 66.61045 4.42305 4.3591   -2 -0.688704077 50.67063 6.786645 4.890887\n3   1  0.2 67.05276 4.42308 4.3591   -2 -0.004409401 51.15627 7.210242 4.822016\n        vn       sn     deltav\n1 4.420080 15.96307 -0.0029200\n2 4.890887 11.58072  0.4678365\n3 4.822016 11.53739  0.3989361\n\n\n\n\n\nresult_rcpp &lt;- simulate_gipps_rcpp(0.1, \n                         1, \n                         \n                         dfn1_r,\n                         'PrecVehLocalY',\n                         'PrecVehVel',\n                         \n                         list(dfn1_r$Local.Y[1]), \n                         list(dfn1_r$svel[1]), \n                         list(unique(dfn1_r$PrecVehLength)), \n                         \n                         2, \n                         max(dfn1_r$svel), \n                         1.2, \n                         -1.5, \n                         -2)\n\nhead(result_rcpp, 3)\n\n  fvn Time      xn1     vn1    ln1           bn       xn       vn       sn\n1   1  0.0 66.16815 4.42300 4.3591  4.708065444 50.20508 4.420080 15.96307\n2   1  0.1 66.61045 4.42305 4.3591 -0.688704077 50.67063 4.890887 15.93982\n3   1  0.2 67.05276 4.42308 4.3591 -0.004409401 51.15627 4.822016 15.89649\n      deltav    vn_ff    vn_cf\n1 -0.0029200 4.420080 4.420080\n2  0.4678365 6.805472 4.890887\n3  0.3989361 7.231150 4.822016\n\n\n\n\n\nresult_julia = simulate_gipps_julia(\n  0.1, \n  1, \n  \n  dfn1_julia,\n  \"PrecVehLocalY\",\n  \"PrecVehVel\",\n  \n  Vector([dfn1_julia[!,\"Local.Y\"][1]]), \n  Vector([dfn1_julia.svel[1]]), \n  Vector(unique(dfn1_julia.PrecVehLength)), \n\n  2, \n  maximum(dfn1_julia.svel), \n  0.1, \n  -1.5, \n  -2\n);\n\n\nfirst(result_julia, 3)\n\n3×10 DataFrame\n Row │ fvn    Time     xn1      vn1      ln1      bn        xn        vn       ⋯\n     │ Int64  Float64  Float64  Float64  Float64  Float64?  Float64?  Float64? ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     1      0.0  66.1681  4.423     4.3591   1.97214   50.2051   4.42008 ⋯\n   2 │     1      0.1  66.6105  4.42305   4.3591   1.95774   50.6569   4.61729\n   3 │     1      0.2  67.0528  4.42308   4.3591   1.94046   51.1285   4.81307\n                                                               2 columns omitted"
  },
  {
    "objectID": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#plotting-the-results",
    "href": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#plotting-the-results",
    "title": "Gipps Model in R, Rcpp, and Julia",
    "section": "Plotting the results",
    "text": "Plotting the results\nFollowing plots compare the speed predicted by the Gipps model with the observed speed of the following vehicle.\n\n\n\nR\nggplot() +\n  geom_line(data = dfn1_r, \n            aes(Time, svel, color=\"Obs. Speed\")) +\n  geom_point(data = result_r %&gt;% filter(fvn==1), \n             aes(Time, vn, color=\"Gipps. Speed-R\")) +\n  geom_line(data = result_rcpp %&gt;% filter(fvn==1), \n            aes(Time, vn, color=\"Gipps. Speed-Rcpp\"))\n\n\n\n\n\n \n\n\nJulia\nusing Plots\np = plot(dfn1_julia.Time, dfn1_julia.svel, label=\"Obs. Speed\");\nplot!(p, result_julia.Time, result_julia.vn, label = \"Gipps Speed\")"
  },
  {
    "objectID": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#measuring-the-running-time",
    "href": "posts/2022-08-15-gipps-model-in-r-and-julia/gipps.html#measuring-the-running-time",
    "title": "Gipps Model in R, Rcpp, and Julia",
    "section": "Measuring the running time",
    "text": "Measuring the running time\nSince the main reason for using Julia and Rcpp was to speed-up the calculations, I now benchmark the code running time:\n\n\n\nR\nmicrobenchmark(\n  \"R\" = simulate_gipps_r(0.1, \n                         1, \n                         \n                         dfn1_r,\n                         'PrecVehLocalY',\n                         'PrecVehVel',\n                         \n                         list(dfn1_r$Local.Y[1]), \n                         list(dfn1_r$svel[1]), \n                         list(unique(dfn1_r$PrecVehLength)), \n                         \n                         2, \n                         max(dfn1_r$svel), \n                         1.2, \n                         -1.5, \n                         -2),\n  \"Rcpp\" = simulate_gipps_rcpp(0.1, \n                               1, \n                               \n                               dfn1_r,\n                               'PrecVehLocalY',\n                               'PrecVehVel',\n                               \n                               list(dfn1_r$Local.Y[1]), \n                               list(dfn1_r$svel[1]), \n                               list(unique(dfn1_r$PrecVehLength)), \n                               \n                               2, \n                               max(dfn1_r$svel), \n                               1.2, \n                               -1.5, \n                               -2),\n  times = 1000L,\n  unit = \"ms\"\n)\n\nUnit: milliseconds\n expr    min      lq     mean  median      uq     max neval\n    R 5.2794 5.71390 6.440167 6.05135 6.52950 38.2684  1000\n Rcpp 1.2979 1.46895 1.780119 1.55145 1.75615 14.1584  1000\n\n\n\n \n\n\nJulia\n@benchmark simulate_gipps_julia(\n  0.1, \n  1, \n  \n  dfn1_julia,\n  \"PrecVehLocalY\",\n  \"PrecVehVel\",\n  \n  Vector([dfn1_julia[!,\"Local.Y\"][1]]), \n  Vector([dfn1_julia.svel[1]]), \n  Vector(unique(dfn1_julia.PrecVehLength)), \n  \n  2, \n  maximum(dfn1_julia.svel), \n  0.1, \n  -1.5, \n  -2\n)\n\nBenchmarkTools.Trial: 4286 samples with 1 evaluation.\n Range (min … max):  941.700 μs …   5.675 ms  ┊ GC (min … max): 0.00% … 78.73%\n Time  (median):       1.056 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):     1.157 ms ± 389.636 μs  ┊ GC (mean ± σ):  2.42% ±  6.91%\n\n  ▆██▇▆▅▅▄▄▃▂▂▁▁▁                                               ▂\n  █████████████████▇▅█▇▇▆▇▇▆▄▆▄▅▃▆▄▅▅▄▃▅▅▄▁▅▃▄▄▄▅▅▁▅▁▄▃▄▄▁▃▃▃▄▄ █\n  942 μs        Histogram: log(frequency) by time       3.25 ms &lt;\n\n Memory estimate: 424.88 KiB, allocs estimate: 20491.\n\n\n\n\nThe results clearly show that both Julia and Rcpp are significantly faster than R. Therefore, using the Julia implementation would save a lot of time if I use this function in simulations and calibration.\nPlease leave comments below to suggest any improvements. Feel free to use the code in this post if you find anything useful.\nAnimation Bonus:\n\n\nCode\nlibrary(gganimate)\n\nggplot(data = result_r) +\n  geom_rect(aes(xmin = xn1 - ln1,\n                xmax = xn1,\n                \n                ymin = 0.628,\n                ymax = 3.028)) +\n  geom_rect(aes(group = fvn,\n                fill = as.factor(fvn),\n                xmin = xn - 5,\n                xmax = xn,\n                \n                ymin = 0.628,\n                ymax = 3.028)) +\n  # geom_hline(yintercept = 3.6, linetype = \"longdash\", color = \"white\") +\n  geom_text(aes(x=xn-2, y = 6, \n                label = paste(\"Following Car\\nSpeed =\", round(vn,2), \"m/s\")),\n            color = \"white\") +\n  geom_text(aes(x=xn1-2, y = 6, color = \"white\",\n                label = paste(\"Lead Car\\nSpeed =\", round(vn1,2), \"m/s\")),\n            color = \"white\") +\n  geom_segment(aes(x = xn,\n                   xend = xn1-(unique(dfn1_r$PrecVehLength)),\n                   y = 2.5,\n                   yend= 2.5), color = \"white\",\n               arrow = arrow(length = unit(0.1, \"inches\"), ends = \"both\")) +\n  geom_text(aes(x=xn + 0.5*sn, y = 1.5, color = \"white\",\n                label = paste(\"Spacing =\", round(sn,2), \"m\")),\n            color = \"white\") +\n  coord_equal(ratio=0.7) +\n  transition_manual(Time) +\n  ease_aes() +\n  view_follow()+\n  theme_void() +\n  theme(legend.position = \"none\",\n        panel.background = element_rect(fill = \"black\", color = \"black\"))"
  },
  {
    "objectID": "projects/avhdv.html",
    "href": "projects/avhdv.html",
    "title": "Driver Behaviour in mixed traffic of Autonomous Vehicles",
    "section": "",
    "text": "Assisted in the development of the driving simulator study by specifying the behaviors of autonomous and human-driven vehicles in the simulation\n\nCollected driving and sensor data by conducting simulator studies\n\nExtracted and analyzed data"
  },
  {
    "objectID": "projects/avhdv.html#development-of-an-algorithm-to-improve-autonomous-driving-performance-in-a-mixed-traffic-of-autonomous-and-human-driving-vehicle-ministry-of-science-and-ict-south-korea-2022-present",
    "href": "projects/avhdv.html#development-of-an-algorithm-to-improve-autonomous-driving-performance-in-a-mixed-traffic-of-autonomous-and-human-driving-vehicle-ministry-of-science-and-ict-south-korea-2022-present",
    "title": "Driver Behaviour in mixed traffic of Autonomous Vehicles",
    "section": "",
    "text": "Assisted in the development of the driving simulator study by specifying the behaviors of autonomous and human-driven vehicles in the simulation\n\nCollected driving and sensor data by conducting simulator studies\n\nExtracted and analyzed data"
  },
  {
    "objectID": "projects/distracted-driving.html",
    "href": "projects/distracted-driving.html",
    "title": "Distracted Driving",
    "section": "",
    "text": "Assisted in the development of driving simulator scenarios to evaluate driver distraction\n\nDeveloped and deployed a dashboard application that worked with real-time driving simulator data to evaluate driver distraction due to music and navigation tasks\n\nCreated computer programs to extract and analyze driving data and participant heart rate data"
  },
  {
    "objectID": "projects/distracted-driving.html#mitigating-distracted-driving-based-on-understanding-of-drivers-personality-motivational-and-mobile-phone-dependency-characteristics.-road-safety-research-partnership-program-rsrpp-ministry-of-transportation-of-ontario-2020-present",
    "href": "projects/distracted-driving.html#mitigating-distracted-driving-based-on-understanding-of-drivers-personality-motivational-and-mobile-phone-dependency-characteristics.-road-safety-research-partnership-program-rsrpp-ministry-of-transportation-of-ontario-2020-present",
    "title": "Distracted Driving",
    "section": "",
    "text": "Assisted in the development of driving simulator scenarios to evaluate driver distraction\n\nDeveloped and deployed a dashboard application that worked with real-time driving simulator data to evaluate driver distraction due to music and navigation tasks\n\nCreated computer programs to extract and analyze driving data and participant heart rate data"
  },
  {
    "objectID": "projects/rss.html",
    "href": "projects/rss.html",
    "title": "Machine Learning to Classify Drivers",
    "section": "",
    "text": "Developed clusters of drivers with similar behaviours based on self-reported, psychophysiological, and performance metrics within a simulated environment\n\nApplied machine learning models to predict moderate and conservative drivers\n\nRead a blog post here"
  },
  {
    "objectID": "projects/rss.html#classifying-drivers-using-supervised-and-unsupervised-machine-learning-techniques.-in-collaboration-with-university-of-south-florida-2021---2022",
    "href": "projects/rss.html#classifying-drivers-using-supervised-and-unsupervised-machine-learning-techniques.-in-collaboration-with-university-of-south-florida-2021---2022",
    "title": "Machine Learning to Classify Drivers",
    "section": "",
    "text": "Developed clusters of drivers with similar behaviours based on self-reported, psychophysiological, and performance metrics within a simulated environment\n\nApplied machine learning models to predict moderate and conservative drivers\n\nRead a blog post here"
  },
  {
    "objectID": "projects/vsl.html",
    "href": "projects/vsl.html",
    "title": "Variable Speed Limit System in Ontario, Canada",
    "section": "",
    "text": "Assisted in the development of a new criteria to propose various sites for the deployment of the Variable Speed Limit System in Ontario\nAnalyzed the weather patterns in Ontario to identify the locations with the most severe weather conditions\nDeveloped an interactive map application for the visualization of precipitation and proposed sites for the Variable Speed Limit System in Ontario"
  },
  {
    "objectID": "projects/vsl.html#safety-impacts-of-a-variable-speed-limit-system.-highway-infrastructure-innovation-funding-program-hiifp-ministry-of-transportation-of-ontario-2018-2019",
    "href": "projects/vsl.html#safety-impacts-of-a-variable-speed-limit-system.-highway-infrastructure-innovation-funding-program-hiifp-ministry-of-transportation-of-ontario-2018-2019",
    "title": "Variable Speed Limit System in Ontario, Canada",
    "section": "",
    "text": "Assisted in the development of a new criteria to propose various sites for the deployment of the Variable Speed Limit System in Ontario\nAnalyzed the weather patterns in Ontario to identify the locations with the most severe weather conditions\nDeveloped an interactive map application for the visualization of precipitation and proposed sites for the Variable Speed Limit System in Ontario"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Variable Speed Limit System in Ontario, Canada\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMachine Learning to Classify Drivers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDriver Behaviour in mixed traffic of Autonomous Vehicles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDistracted Driving\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "sketchy-html/sketchy-html.html",
    "href": "sketchy-html/sketchy-html.html",
    "title": "Quarto Sketchy Theme",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "sketchy-html/sketchy-html.html#quarto",
    "href": "sketchy-html/sketchy-html.html#quarto",
    "title": "Quarto Sketchy Theme",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "sketchy-html/sketchy-html.html#running-code",
    "href": "sketchy-html/sketchy-html.html#running-code",
    "title": "Quarto Sketchy Theme",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nThe echo: false option disables the printing of code (only output is displayed).\n\nblockquotes are fun\n\nYou can also strike through, cross-off, highlight, and circle text\n\nbox for arbitrary content\n\nTables also work\n\n\n\nDefault\nLeft\nRight\nCenter\n\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1"
  },
  {
    "objectID": "software.html",
    "href": "software.html",
    "title": "Software",
    "section": "",
    "text": "R package for running car-following models.\n Code  Website"
  },
  {
    "objectID": "software.html#carfollowingmodels",
    "href": "software.html#carfollowingmodels",
    "title": "Software",
    "section": "",
    "text": "R package for running car-following models.\n Code  Website"
  },
  {
    "objectID": "software.html#daqr",
    "href": "software.html#daqr",
    "title": "Software",
    "section": "daqr",
    "text": "daqr\nR package for reading driving simulator data from daq files.\n Code  Website"
  },
  {
    "objectID": "software.html#opendatawindsor",
    "href": "software.html#opendatawindsor",
    "title": "Software",
    "section": "opendatawindsor",
    "text": "opendatawindsor\nR package for downloading data from City of Windsor Open Data Portal.\n Code"
  },
  {
    "objectID": "teaching.html",
    "href": "teaching.html",
    "title": "Teaching",
    "section": "",
    "text": "This workshop is held in Winter 2023 for the members of Transportation Systems Innovation Lab at University of Windsor."
  },
  {
    "objectID": "teaching.html#machine-learning-basics-workshop-series",
    "href": "teaching.html#machine-learning-basics-workshop-series",
    "title": "Teaching",
    "section": "",
    "text": "This workshop is held in Winter 2023 for the members of Transportation Systems Innovation Lab at University of Windsor."
  },
  {
    "objectID": "teaching.html#data-analytics-instructor-at-st.-clair-college",
    "href": "teaching.html#data-analytics-instructor-at-st.-clair-college",
    "title": "Teaching",
    "section": "Data Analytics Instructor at St. Clair College",
    "text": "Data Analytics Instructor at St. Clair College\n\n\n\n\n\nSemester\nCourse(s)\n\n\n\n\nWinter 2023\nCapstone Project\n\n\nFall 2022\nMachine Learning I\n\n\nSpring 2022\nCapstone Project\n\n\nWinter 2022\nMachine Learning I, Capstone Project\n\n\nFall 2021\nIntro. to Artificial Intelligence, Machine Learning I\n\n\nSpring 2021\nMachine Learning I, Basic Statistics and Exploratory Data Analysis\n\n\nWinter 2021\nAnalytic Tools and Decision Making, Basic Statistics and Exploratory Data Analysis\n\n\nFall 2020\nAnalytic Tools and Decision Making, Ethics for Analytics\n\n\nSpring 2020\nIT Service Management\n\n\nFall 2019\nAnalytic Tools and Decision Making\n\n\nSpring 2019\nIT Service Management\n\n\n\n\n\n\n\n\nCapstone Projects (Spring 2022)"
  },
  {
    "objectID": "teaching.html#graduate-assistant-at-university-of-windsor",
    "href": "teaching.html#graduate-assistant-at-university-of-windsor",
    "title": "Teaching",
    "section": "Graduate Assistant at University of Windsor",
    "text": "Graduate Assistant at University of Windsor\n\n\n\n\n\nSemester\nCourse\nInstructor\n\n\n\n\nWinter 2018\nTechnical Communications\nDr. Jacqueline Stagner\n\n\nSpring 2017\nHighway Design and Construction\nDr. Chris Lee\n\n\nWinter 2017\nTreatment of Experimental Data\nDr. Lindsay Miller\n\n\nFall 2016\nEngineering Software Fundamentals\nDr. Edward Lang\n\n\nSpring 2016\nTransportation and Traffic Engineering\nDr. Chris Lee\n\n\nWinter 2016\nNumerical Analysis for Engineering\nDr. Edward Lang\n\n\nFall 2015\nEngineering Software Fundamentals\nDr. Edward Lang\n\n\nSpring 2015\nHighway Design and Construction\nDr. Chris Lee\n\n\nFall 2014\nEngineering Profession\nDr. Leo Oriet\n\n\nSpring 2014\nTransportation Systems Analysis\nDr. Hanna Maoh\n\n\nSpring 2014\nHighway Design and Construction\nDr. Chris Lee\n\n\nWinter 2014\nCivil Engineering Information System\nDr. Hanna Maoh\n\n\nFall 2013\nEngineering Mechanics I\nDr. Amr El Ragaby\n\n\n\n\n\n\n\n\nInteractive Course: R for Driving Simulator Data"
  },
  {
    "objectID": "teaching.html#lecturerlab-engineer-at-university-of-engineering-technology-lahore-2010---2012",
    "href": "teaching.html#lecturerlab-engineer-at-university-of-engineering-technology-lahore-2010---2012",
    "title": "Teaching",
    "section": "Lecturer/Lab Engineer at University of Engineering & Technology, Lahore (2010 - 2012)",
    "text": "Lecturer/Lab Engineer at University of Engineering & Technology, Lahore (2010 - 2012)\nSubjects taught:\n\nRailway Engineering\n\nConstruction Management\n\nConstruction Materials and Machinery"
  },
  {
    "objectID": "teaching.html#guest-lectures",
    "href": "teaching.html#guest-lectures",
    "title": "Teaching",
    "section": "Guest Lectures",
    "text": "Guest Lectures\n\n“Reaction Time in Car-following” Lecture for Institute of Highway Engineers, UK."
  },
  {
    "objectID": "posts/visual_looming/vlooming.html",
    "href": "posts/visual_looming/vlooming.html",
    "title": "How do drivers perceive slow traffic on highways?",
    "section": "",
    "text": "Imagine you are driving on a highway; the weather is beautiful and you are enjoying the tunes on the radio. You see a small figure farther down the road and after a few moments you know it is another car travelling much like you.\nA few more seconds pass and you feel slight unease with the car dozens of meters away from you. Something is wrong but you don’t know what. May be the car is slower than the usual highway speed. Then, all of a sudden, you notice that the car is stopped in the middle of the road! Car’s brake lights are on but not too sharp in the broad daylight. You swerve to the other lane with no traffic, thinking what would have happened if you hadn’t.\nThis was perhaps an extreme example. Cars don’t just stop in the middle of highways. But situations like these do and can happen. Similar situations with slower lead cars happen everyday, where you need to safely overtake the car.\nThese questions have always been important to answer in traffic flow and psychology studies because they are connected to road safety. Understanding how drivers perceive and make decisions is even more important today to improve self-driving technology.\nThis post introduces you to visual looming that help drivers perceive relative motion. Read on to learn how the Wiedemann car-following model utilizes visual looming to predict reaction behind a lead vehicle."
  },
  {
    "objectID": "posts/visual_looming/vlooming.html#what-is-visual-looming",
    "href": "posts/visual_looming/vlooming.html#what-is-visual-looming",
    "title": "How do drivers perceive slow traffic on highways?",
    "section": "What is Visual Looming?",
    "text": "What is Visual Looming?\n\n\n\n\nSource: Digital camera world\n\n\nFor most people, looking at this image would likely have an involuntary reaction - an effort to save them from the impending impact of the ball. But what exactly happens in your brain that tells you to save yourself from this looming threat?\nVisual looming (or just looming) is a measure of the growth of an image of an object approaching you. This growth of the image happens at your eye, specifically retina, where a 2D (two-dimensional) image forms. The 2D image grows in size as an object gets closer to you. Since the approaching object looms over the eye, this process is called looming.\nSo, how is looming related to driving? As you gradually approach a slower lead vehicle, the 2D image of the rear of the lead vehicle grows on your retina. The animation below shows you that the width and height of the truck’s rear subtend visual angles (\\theta) on your eye (you are in the red car). One way to quantify looming is to estimate the rate of change of a visual angle, called as angular velocity, measured in radians per second. Thus, angular velocity measures the speed of the image growth on your eye. The line chart at the bottom-right shows that angular velocity is not constant: the closer you get to the truck, the faster the image grows on your eye.\n\n\n\nAn oversimplification of how drivers perceive a slow lead vehicle\n\n\nAll of this happens on your eye without much cognitive processing. After all, drivers are not physicists who’d need to use euqations of motion to determine when they need to steer away to another lane or apply brakes to avoid collision. Even if drivers want to do that, they won’t be successful as they do not know the speed and distance to the lead vehicle.\n\nInteractive example\nIn the following application, you can move ahead in time to see how the image of the lead car grows in size as the following car approaches it. The first plot shows the speed of the following car as it gets closer to a lead car with a constant speed (Moving LV) or zero speed (Stationary LV). The second plot shows the position of the gas pedal of the following car and the angular velocity.\n\n\nIn both figures above, you see that angular velocity increases with time. Researchers believe that there is some driver-specific value of angular velocity that is perceivable (just noticeable).\n\nThe value of angular velocity where drivers detect that a lead vehicle is slower than them is the threshold of angular velocity, \\theta_{TH}.\n\nIn the Moving LV scenario above, move the Time slider to 89 s to see that the driver stepped-off the gas pedal (gas pedal position = 0) when angular velocity grew significantly. At this time, the angular velocity was about 0.0003 rad/s. Therefore, the threshold of angular velocity for this driver was 0.0003 rad/s."
  },
  {
    "objectID": "posts/visual_looming/vlooming.html#wiedemann-car-following-model",
    "href": "posts/visual_looming/vlooming.html#wiedemann-car-following-model",
    "title": "How do drivers perceive slow traffic on highways?",
    "section": "Wiedemann car-following model",
    "text": "Wiedemann car-following model\nWiedemann model divides the car-following process into four distinct states:\n\nFree-driving: Driver strives to drive at a desired speed.\n\nApproaching: Driver detects a slower lead vehicle based on angular velocity threshold (\\theta_{W(TH)}) and slows down to avoid collision. Angular velocity can be estimated as the width of the lead vehicle divided by the distance to lead vehicle. Wiedemann model uses the parameter CX that has the following relation with the threshold of angular velocity.\n\n\n\nFollowing: Driver follows the lead vehicle at the same speed with small variation. Angular velocity threshold informs driver if they are getting too close to or loosing the lead vehicle.\nBraking: Driver applies brake if the distance to the lead vehicle gets smaller than the driver-specific safety distance.\n\n\n\n\n\n\n\nExpand to see Wiedemann model equations\n\n\n\n\n\nFollowing are all the equations of the original Wiedemann car-following model. Want to learn more? Check out (Durrani, Lee, and Maoh 2016) and (Durrani and Lee 2019). Or contact me.\n BMAX = BMAXmult \\times (V_{MAX} - V \\times FaktorV) \n  FaktorV = \\frac{V_{MAX}}{V_{DESIRED} + FAKTORVmult(V_{MAX} - V_{DESIRED})} \n  BNULL = BNULLmult \\times (RND4(i) + NRND) \n  AX = L + AXadd + (RND1(i) \\times AXmult) \n  SDV = \\left( \\frac{DX - AX}{CX} \\right)^2 \n  CX = CXconst \\times (CXadd + CXmult \\times (RND1(i) + RND2(i))) \n  B(i)_{App} = \\frac{1}{2} \\times \\frac{{DV}^2}{ABX - DX} + B(i - 1) + \\frac{(1 - RND2(i)) \\times (1 - 2 \\times NRND)}{R(i)} \n  ABX = AX + (BXadd + BXmult \\times RND1(i))\\times \\sqrt{V} \n  CLDV = SDV \\times EX^2 \n  EX = EXadd + EXmult \\times (NRND - RND2(i)) \n  OPDV = CLDV \\times (-OPDVadd - OPDVmult \\times NRND) \n  SDX = AX + EX \\times (BXadd + BXmult \\times RND1(i))\\times \\sqrt{V} \n  B(i)_{Emg} = \\frac{1}{2} \\times \\frac{{DV}^2}{AX - DX} + B(i - 1) + BMIN \\times \\frac{(ABX - DX)}{(ABX - AX)} + \\frac{(1 - RND2(i)) \\times (1 - 2 \\times NRND)}{R(i)} \n  BMIN = -BMINadd - BMINmult \\times RND3(i) + BMINVmult \\times V \n\n\n\nSince most of the driving happens in following and approaching states, driver reactions are assumed to be initiated when the threshold of angular velocity is reached.\n\nInteractive example (free-driving to approaching)\nThe application below enables you to control a few model parameters of the Wiedemann model to reproduce the actual speed of a following car that is approaching a slow/stopped lead car. Try changing the desired speed, BMAXmult, and CX to make the predicted speed (dashed line) as close as possible to the actual speed (solid line).\n\n\nAs you change these parameter values, notice how that changes the measures above the plot. You see:\n\nSum of Squared Error: Mean difference between the actual and predicted distance to the lead vehicle\n\nPredicted and observed reaction times: Reaction time was estimated as the time when the driver transitions from the free-driving state to the approaching state. These states were manually annotated in the actual data and were also predicted by the Wiedemann model based on the angular velocity threshold\n\nAV threshold: Angular velocity threshold estimated from the observed and predicted data"
  },
  {
    "objectID": "posts/visual_looming/vlooming.html#visual-looming-is-important",
    "href": "posts/visual_looming/vlooming.html#visual-looming-is-important",
    "title": "How do drivers perceive slow traffic on highways?",
    "section": "Visual looming is important",
    "text": "Visual looming is important\nFor many, many years into the future, humans will be driving manual/partially automated vehicles. Therefore, it is essential that we understand what influences drivers’ decision making and how can we make all road users safe. I hope this post made you realize the importance of looming (angular velocity) in driving. Hopefully, you’d recognize that looming cannot be ignored as long as a driver is involved even for a small part of the journey.\nIn a future post, I will show you an alternative but seemingly more realistic model of drivers’ decision making in approaching slower vehicles that also utilizes looming. See you then."
  },
  {
    "objectID": "rpy.html",
    "href": "rpy.html",
    "title": "Introduction to R and Python for Data Analysis",
    "section": "",
    "text": "Google Maps image of Interstate-80 (I-80) Freeway Segment.\nThis series uses the I-80 dataset from NGSIM project.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGetting started with exploratory data visualization\n\n\n\nvisualization\n\n\nggplot2\n\n\nplotnine\n\n\nplotting\n\n\ngraphs\n\n\n\nLearn to use ggplot2 and plotnine to explore data\n\n\n\nUmair Durrani\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTransforming data to make it fit for analysis\n\n\n\nvisualization\n\n\ndplyr\n\n\npandas\n\n\nsiuba\n\n\ndata-transformation\n\n\nmutate\n\n\nfilter\n\n\n\nLearn to use dplyr, pandas and siuba to filter rows & create and change columns\n\n\n\nUmair Durrani\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "rpy/data_visualization/data_visualization.html",
    "href": "rpy/data_visualization/data_visualization.html",
    "title": "Getting started with exploratory data visualization",
    "section": "",
    "text": "We begin by loading the required visualization packages:\nNext we load data and take a quick look:\nThe dataset was stored as a parquet file in a folder named data. parquet format is faster to read and write compared to the csv format. If you’d like to know more about the source of the data and how to store it yourself, read this post."
  },
  {
    "objectID": "rpy/data_visualization/data_visualization.html#load-data",
    "href": "rpy/data_visualization/data_visualization.html#load-data",
    "title": "Getting started with exploratory data visualization",
    "section": "Load data",
    "text": "Load data\n\nRPython\n\n\n\ndf &lt;- arrow::read_parquet(\"data/df.parquet\")\nknitr::kable(head(df))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npair_id\ntime\nactual_time\nduration\nvehicle_id\nframe_id\nlocal_x\nlocal_y\nv_length\nv_width\nv_class\nv_vel\nv_acc\nlane_id\npreceding\nspace_headway\ntime_headway\npreceding_local_y\npreceding_length\npreceding_width\npreceding_class\npreceding_vel\npreceding_acc\n\n\n\n\n47-39\n0.0\n2005-04-13 15:59:45\n32.1\n47\n510\n2.4\n22.16\n4.54\n1.8\n2\n3.64\n1.10\n1\n39\n18.40\n2.63\n37.21\n4.82\n1.95\n2\n7.98\n1.36\n\n\n47-39\n0.1\n2005-04-13 15:59:46\n32.1\n47\n511\n2.4\n22.53\n4.54\n1.8\n2\n3.76\n1.59\n1\n39\n18.65\n2.66\n38.02\n4.82\n1.95\n2\n8.11\n1.20\n\n\n47-39\n0.2\n2005-04-13 15:59:46\n32.1\n47\n512\n2.4\n22.91\n4.54\n1.8\n2\n3.92\n1.98\n1\n39\n18.55\n2.65\n38.83\n4.82\n1.95\n2\n8.23\n1.04\n\n\n47-39\n0.3\n2005-04-13 15:59:46\n32.1\n47\n513\n2.4\n23.31\n4.54\n1.8\n2\n4.12\n2.19\n1\n39\n18.44\n2.63\n39.66\n4.82\n1.95\n2\n8.33\n0.86\n\n\n47-39\n0.4\n2005-04-13 15:59:46\n32.1\n47\n514\n2.4\n23.74\n4.54\n1.8\n2\n4.32\n2.13\n1\n39\n18.48\n2.64\n40.50\n4.82\n1.95\n2\n8.42\n0.73\n\n\n47-39\n0.5\n2005-04-13 15:59:46\n32.1\n47\n515\n2.4\n24.18\n4.54\n1.8\n2\n4.54\n2.20\n1\n39\n18.40\n2.63\n41.34\n4.82\n1.95\n2\n8.50\n0.58\n\n\n\n\n\nThe kable() function makes the table output pretty in html.\n\n\n\ndf = pd.read_parquet(\"data/df.parquet\")\ndf.head()\n\n  pair_id  time  ... preceding_vel  preceding_acc\n0   47-39   0.0  ...          7.98           1.36\n1   47-39   0.1  ...          8.11           1.20\n2   47-39   0.2  ...          8.23           1.04\n3   47-39   0.3  ...          8.33           0.86\n4   47-39   0.4  ...          8.42           0.73\n\n[5 rows x 23 columns]"
  },
  {
    "objectID": "rpy/data_visualization/data_visualization.html#visualizing-distributions",
    "href": "rpy/data_visualization/data_visualization.html#visualizing-distributions",
    "title": "Getting started with exploratory data visualization",
    "section": "Visualizing distributions",
    "text": "Visualizing distributions\n\nBoxplot\nLet’s plot vehicle length first.\nStart with an empty canvas:\n\nRPython\n\n\n\nggplot(data = df)\n\n\n\n\n\n\n\nggplot(data = df)\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n\n\n\n\n\nThen add aesthetic mappings (we map vehicle class to x-axis and vehicle length to y-axis):\n\nRPython\n\n\n\nggplot(data = df,\n       mapping = aes(x = v_class, y = v_length))\n\n\n\n\n\n\n\nggplot(data = df,\n       mapping = aes(x = \"v_class\", y = \"v_length\"))\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n\n\nNote that the dataset df is specified without quotes but the columns v_class and v_length are provided in quotes.\n\n\n\nYou see the range of vehicle class and length variables on the plot, but there is no data on the plot pane because we did not specify how to draw it.\nLet’s use the geometrical object boxplot to visualize the distribution of length of various vehicles:\n\nRPython\n\n\n\nggplot(data = df,\n       mapping = aes(x = v_class, y = v_length)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n(\n  ggplot(data = df,\n       mapping = aes(x = \"v_class\", y = \"v_length\")) +\n  geom_boxplot()\n  )\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n\n\nNote that the code is wrapped in parentheses (). This is because the plot would not render without wrapping the code it in ().\n\n\n\n\n\n\nReading a Boxplot: https://flowingdata.com/2008/02/15/how-to-read-and-use-a-box-and-whisker-plot/\nHere we see three vehicle classes with the distribution of their length. Based on the information that 1, 2, and 3 represent motorcycle, car and heavy-vehicle, we change the labels on the plot:\n\nRPython\n\n\n\nggplot(data = df,\n       mapping = aes(x = v_class, y = v_length)) +\n  geom_boxplot() +\n  scale_x_discrete(labels = c(\"Motorcycle\", \"Car\", \"HV\"))\n\n\n\n\nThe function c() means combine. Here we combine three string (text) items.\n\n\n\n(\n  ggplot(data = df,\n       mapping = aes(x = \"v_class\", y = \"v_length\")) +\n  geom_boxplot() +\n  scale_x_discrete(labels = [\"Motorcycle\", \"Car\", \"HV\"])\n  )\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n\n\n[] combines multiple strings in a data structure called a list.\n\n\n\nWe used scale_x_discrete() because v_class is a discrete data type with 3 categories. We used the parameter labels to specify the custom labels that replaced the actual data (1, 2, and 3) on the plot.\nThe main finding in this plot is that heavy-vehicles are much longer than cars and motorcycles. To make this plot even more readable, we provide the labs (labels) of the plot:\n\nRPython\n\n\n\nggplot(data = df,\n       mapping = aes(x = v_class, y = v_length)) +\n  geom_boxplot() +\n  scale_x_discrete(labels = c(\"Motorcycle\", \"Car\", \"HV\")) +\n  labs(x = NULL,\n       y = \"Length (m)\")\n\n\n\n\nSpecifying NULL for the x-axis label completely removes it.\n\n\n\n(\n  ggplot(data = df,\n       mapping = aes(x = \"v_class\", y = \"v_length\")) +\n  geom_boxplot() +\n  scale_x_discrete(labels = [\"Motorcycle\", \"Car\", \"HV\"]) +\n  labs(x = \"\",\n       y = \"Length (m)\")\n  )\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n\n\nSpecifying an empty string (\"\") for the x-axis label removes it.\n\n\n\n\n\nHistogram and Density plots\nHistogram and Density plots also help in understanding a variable distribution.\n\n\nHow histograms work: https://flowingdata.com/2017/06/07/how-histograms-work/\nLet’s look at the histogram of speed (v_vel):\n\nRPython\n\n\n\n# Speed distribution\nggplot(data = df) +\n  geom_histogram(aes(x = v_vel, color = v_class, fill = v_class), \n                 alpha = 0.4) +\n  scale_color_discrete(labels = c(\"motorcycle\", \"car\", \"HV\")) +\n  scale_fill_discrete(labels = c(\"motorcycle\", \"car\", \"HV\")) +\n  labs(x = \"Speed (m/s)\",\n       color = \"Vehicle Class\",\n       fill = \"Vehicle Class\")\n\n\n\n\n\n\n\n# Speed distribution\n(\n  ggplot(data = df) +\n  geom_histogram(aes(x = \"v_vel\", color = \"v_class\", fill = \"v_class\"), \n                 alpha = 0.4) +\n  scale_color_discrete(labels = [\"motorcycle\", \"car\", \"HV\"]) +\n  scale_fill_discrete(labels = [\"motorcycle\", \"car\", \"HV\"]) +\n  labs(x = \"Speed (m/s)\",\n       color = \"Vehicle Class\",\n       fill = \"Vehicle Class\")\n       )\n\n&lt;Figure Size: (640 x 480)&gt;\n\nC:\\Users\\umair\\ANACON~1\\envs\\homl3\\lib\\site-packages\\plotnine\\stats\\stat_bin.py:109: PlotnineWarning: 'stat_bin()' using 'bins = 126'. Pick better value with 'binwidth'.\n\n\n\n\n\n\n\n\nIn this piece of code, we have used many new features:\n\ncolor aesthetic: To map the v_class variable to the border color (also called as stroke) of the bars in histogram\n\nfill aesthetic: To map the v_class variable to the fill color of the bars in histogram\n\nalpha property: The transparency level of the visualization. 0.4 means 40%. The default is 100%. Note that alpha is provided outside the aesthetics function\n\nTwo scales are provided, one each for color and fill aesthetics\n\nWithin labs() the labels for color and fill aesthetics are also provided in addition to the x aesthetic\n\nYou may have noticed that y aesthetic is not specified here. This is because observation count was first calculated by ggplot2 in each interval of speed. Then the count was mapped to y.\nThe height of each bar in a histogram corresponds to the count of observations (rows in a dataframe) of the variable (speed in this case). We can see that the speed typically varies between 5 - 20 m/s. However, since the histograms are plotted on top of each other AND the count of observations varies significantly between different vehicle classes, we need a better visualization.\nInstead of count on y-axis, we can ask ggplot to estimate the density and map it as the y aesthetic:\n\nRPython\n\n\n\nggplot(data = df) +\n  geom_density(aes(x = v_vel, color = v_class, fill = v_class), \n                 alpha = 0.4) +\n  scale_color_discrete(labels = c(\"motorcycle\", \"car\", \"HV\")) +\n  scale_fill_discrete(labels = c(\"motorcycle\", \"car\", \"HV\")) +\n  labs(x = \"Speed (m/s)\",\n       color = \"Vehicle Class\",\n       fill = \"Vehicle Class\")\n\n\n\n\n\n\n\n(\n  ggplot(data = df) +\n  geom_density(aes(x = \"v_vel\", color = \"v_class\", fill = \"v_class\"), \n                 alpha = 0.4) +\n  scale_color_discrete(labels = [\"motorcycle\", \"car\", \"HV\"]) +\n  scale_fill_discrete(labels = [\"motorcycle\", \"car\", \"HV\"]) +\n  labs(x = \"Speed (m/s)\",\n       color = \"Vehicle Class\",\n       fill = \"Vehicle Class\")\n       )\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n\n\n\n\n\nNow we can clearly see the differences in the speed distribution of different types of vehicles. Most motorcycles were much faster than cars and HVs."
  },
  {
    "objectID": "rpy/data_visualization/data_visualization.html#scatterplot",
    "href": "rpy/data_visualization/data_visualization.html#scatterplot",
    "title": "Getting started with exploratory data visualization",
    "section": "Scatterplot",
    "text": "Scatterplot"
  },
  {
    "objectID": "rpy/data_visualization/data_visualization.html#visualizing-relationships",
    "href": "rpy/data_visualization/data_visualization.html#visualizing-relationships",
    "title": "Getting started with exploratory data visualization",
    "section": "Visualizing relationships",
    "text": "Visualizing relationships\nSpace headway (or spacing) is generally assumed to vary with vehicle speed on highways. We can look at this relationship by mapping both the variables to x and y aesthetics.\nSince there are 68339 observations in these data, using a hexagonal heatmap seems to be a good choice. ggplot2 documentation defines geom_hex as:\n\nDivides the plane into regular hexagons, counts the number of cases in each hexagon, and then (by default) maps the number of cases to the hexagon fill.\n\nLet’s use it:\n\nRPython\n\n\n\nggplot(data = df,\n       aes(x = v_vel, y = space_headway)) +\n  geom_hex() +\n  geom_smooth(se = FALSE, color = \"orange\") +\n  labs(x = \"Speed (m/s)\",\n       y = \"Spacing (m)\")\n\n\n\n\n\n\ngeom_hex is not yet implemented in plotnine. So, we create a scatterplot using geom_point():\n\n(\n  ggplot(data = df, \n        mapping = aes(x = \"v_vel\", y = \"space_headway\")) +\n  geom_point(alpha = 0.1) +\n  geom_smooth(se = False, color = \"orange\") +\n  labs(x = \"Speed (m/s)\",\n       y = \"Spacing (m)\")\n       )\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n\n\n\n\n\nThe plot shows a linear relationship between speed and spacing: vehicles at higher speed generally keep a higher spacing from the lead vehicle (preceding vehicle). This relationship is explicitly modeled by ggplot2 behind the scenes as it fits an algorithm to the data. The command used to achieve that is geom_smooth.\nCar-following models employ spacing and speed-difference from the lead vehicle to forecast the speed of the subject vehicle. Let’s plot the spacing vs speed-difference plot to see the typical speed-difference at different levels of spacing:\n\nRPython\n\n\n\nggplot(data = df,\n       aes(x = v_vel - preceding_vel, y = space_headway)) +\n  geom_point(aes(color = (v_vel - preceding_vel) &lt; 0), \n             alpha = 0.5, shape = \"x\") +\n  facet_wrap(~v_class) +\n  labs(x = \"Speed (m/s)\",\n       y = \"Spacing (m)\")\n\n\n\n\n\n\n\n(\n  ggplot(data = df,\n       mapping = aes(x = \"v_vel - preceding_vel\", y = \"space_headway\")) +\n  geom_point(aes(color = \"(v_vel - preceding_vel) &lt; 0\"), \n  alpha = 0.5, shape = \"x\") +\n  facet_wrap(\"~v_class\") +\n  labs(x = \"Speed (m/s)\",\n       y = \"Spacing (m)\")\n       )\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n\n\n\n\n\nIn this scatterplot, we used four new things:\n\nmapped a calculation from two columns to the x aesthetic\n\nmapped the calculation(v_vel - preceding_vel) &lt; 0 to colour\nspecified a different shape of the data points. You can find more shapes here\n\ncreated subplots for each v_class by specifying it in facet_wrap(). Another option is facet_grid()\n\nThe scatterplot shows that most of the data lies between -2.5 and 2.5 m/s."
  }
]